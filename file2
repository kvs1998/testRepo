# In your app.py, within tab_refresh_stats, right above st.subheader("Filtered Raw Data (Table View)")

    # ... (previous filters and filtered_stats_df preparation)

    st.divider()
    table_header_cols = st.columns([0.7, 0.3])
    with table_header_cols[0]:
        st.subheader("Filtered Raw Data (Table View)")
    with table_header_cols[1]:
        st.write("") # Spacer
        show_latest_table_data = st.checkbox("Show Latest Data Only", key="latest_table_data_checkbox_stats")

    # --- New: Multi-Column Sort Controls ---
    sort_cols = st.columns(2)
    with sort_cols[0]:
        # Define available columns for sorting (using friendly names for display)
        sortable_columns_display = ['Table Name', 'Refresh Action', 'DATA_TIMESTAMP'] + [friendly_stat_labels[col] for col in statistic_cols_raw]
        
        # Mapping back to raw names for pandas sort_values
        reverse_display_map = {
            'Table Name': 'TABLE_NAME',
            'Refresh Action': 'REFRESH_ACTION',
            'DATA_TIMESTAMP': 'DATA_TIMESTAMP' # Assuming this is not renamed to friendly
        } | friendly_stat_labels # Add friendly_stat_labels for statistic columns
        
        # Combine maps for comprehensive reverse lookup
        full_reverse_map = {v: k for k, v in friendly_stat_labels.items()}
        full_reverse_map['Table Name'] = 'TABLE_NAME'
        full_reverse_map['Refresh Action'] = 'REFRESH_ACTION'
        full_reverse_map['DATA_TIMESTAMP'] = 'DATA_TIMESTAMP'


        selected_sort_columns_display = st.multiselect(
            "Sort by (order matters):",
            options=sortable_columns_display,
            default=['Table Name', 'DATA_TIMESTAMP'], # Default to this multi-sort
            key="table_multi_sort_columns"
        )
        
        # Convert display names back to actual DataFrame column names for sort_values
        actual_sort_columns = [full_reverse_map.get(col_display, col_display) for col_display in selected_sort_columns_display]


    with sort_cols[1]:
        sort_asc_desc = {}
        st.write("Order:")
        # For each selected sort column, allow choosing ASC or DESC
        for i, col_display in enumerate(selected_sort_columns_display):
            sort_asc_desc[col_display] = st.radio(
                f"{col_display}",
                options=['Ascending', 'Descending'],
                index=0 if (col_display != 'DATA_TIMESTAMP') else 1, # Default timestamp to Descending
                horizontal=True,
                key=f"sort_order_{col_display.replace(' ', '_').replace('.', '_')}"
            )
        
        actual_sort_ascending_list = [
            (sort_asc_desc[col_display] == 'Ascending') for col_display in selected_sort_columns_display
        ]


    table_display_columns = ['TABLE_NAME', 'REFRESH_ACTION', 'DATA_TIMESTAMP'] + statistic_cols_raw
    display_df_for_table = filtered_stats_df[table_display_columns].rename(columns=friendly_stat_labels)

    if not display_df_for_table.empty:
        if show_latest_table_data:
            idx = filtered_stats_df.groupby('TABLE_NAME')['DATA_TIMESTAMP_DT'].idxmax()
            display_df_for_table = filtered_stats_df.loc[idx, table_display_columns].rename(columns=friendly_stat_labels)
            st.info("Displaying only the latest refresh entry for each table.")
        
        # --- Apply the programmatic multi-column sort ---
        if actual_sort_columns and not display_df_for_table.empty:
            try:
                display_df_for_table = display_df_for_table.sort_values(
                    by=actual_sort_columns, # Uses the DataFrame's actual column names
                    ascending=actual_sort_ascending_list
                )
            except KeyError as e:
                st.warning(f"Error applying sort: Column '{e}' not found after filtering. Please ensure selected sort columns are valid.")
            except Exception as e:
                st.error(f"An unexpected error occurred during sorting: {e}")

        st.dataframe(display_df_for_table, use_container_width=True)
    else:
        st.info("No data to display in the table based on current filters.")

    st.divider()
# ... (rest of the tab_refresh_stats logic and charts)
