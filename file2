st.header("Refresh Statistics by Action Type and Table")
    st.write("Analyze aggregate row and partition changes, filterable by database, table, and refresh action type.")

    if history_df.empty:
        st.warning("No data loaded from Snowflake. Cannot display refresh statistics.")
        st.stop()

    statistic_cols_for_plot_raw = [
        'NUMINSERTEDROWS', 'NUMDELETEDROWS', 'NUMCOPIEDROWS',
        'NUMADDEDPARTITIONS', 'NUMREMOVEDPARTITIONS'
    ]
    friendly_stat_labels = {
        'NUMINSERTEDROWS': 'Inserted Rows', 'NUMDELETEDROWS': 'Deleted Rows', 'NUMCOPIEDROWS': 'Copied Rows',
        'NUMADDEDPARTITIONS': 'Added Partitions', 'NUMREMOVEDPARTITIONS': 'Removed Partitions'
    }
    reverse_friendly_stat_labels = {v: k for k, v in friendly_stat_labels.items()}


    st.subheader("Apply Filters:")
    filter_cols_stats_row1 = st.columns([1, 1, 1, 1])

    with filter_cols_stats_row1[0]:
        all_databases_stats = ['All'] + sorted(history_df['DATABASE_NAME'].unique().tolist())
        selected_database_stats = st.selectbox(
            "Filter by Database:",
            options=all_databases_stats,
            key="db_filter_stats"
        )

    with filter_cols_stats_row1[1]:
        # Filter schemas based on selected database for schema dropdown
        if selected_database_stats != 'All':
            schemas_in_db_stats = ['All'] + sorted(history_df[history_df['DATABASE_NAME'] == selected_database_stats]['SCHEMA_NAME'].unique().tolist())
        else:
            schemas_in_db_stats = ['All'] + sorted(history_df['SCHEMA_NAME'].unique().tolist())
        selected_schema_stats = st.selectbox(
            "Filter by Schema:",
            options=schemas_in_db_stats,
            key="schema_filter_stats"
        )

    # Initial filtering based on DB and Schema for TABLE_NAME list
    filtered_df_for_table_select = history_df.copy() # Start with a fresh copy for this specific filter list
    if selected_database_stats != 'All':
        filtered_df_for_table_select = filtered_df_for_table_select[filtered_df_for_table_select['DATABASE_NAME'] == selected_database_stats]
    if selected_schema_stats != 'All':
        filtered_df_for_table_select = filtered_df_for_table_select[filtered_df_for_table_select['SCHEMA_NAME'] == selected_schema_stats]

    with filter_cols_stats_row1[2]:
        all_tables_stats_options = ['All'] + sorted(filtered_df_for_table_select['TABLE_NAME'].unique().tolist())
        selected_table_stats = st.multiselect( # This remains multiselect for tables
            "Filter by Table(s):",
            options=all_tables_stats_options,
            default=['All'] if all_tables_stats_options else [],
            key="table_filter_stats_multi"
        )

    with filter_cols_stats_row1[3]:
        # --- REFRESH_ACTION Checkboxes ---
        st.write("Filter by Refresh Action Type(s):") # Title for the checkboxes
        all_action_types_list = sorted(history_df['REFRESH_ACTION'].unique().tolist()) # Get all possible types
        
        # Checkbox for 'Select All/None'
        select_all_actions = st.checkbox("Select All/None", key="select_all_actions_stats")

        # Determine default state for individual checkboxes based on 'Select All/None'
        # This will store the state of each individual checkbox
        action_checkbox_states = {}
        for action_type in all_action_types_list:
            # If 'Select All' is checked, default to True for all; otherwise, default to False
            action_checkbox_states[action_type] = st.checkbox(
                action_type,
                value=select_all_actions, # Set initial value based on 'Select All'
                key=f"action_checkbox_{action_type.replace(' ', '_').replace('/', '_')}_stats" # Unique key for each checkbox
            )
        # Collect selected actions based on individual checkbox states
        selected_action_types_from_checkboxes = [
            action_type for action_type, is_selected in action_checkbox_states.items() if is_selected
        ]
        
        # This is the variable used for filtering
        selected_action_types_final = selected_action_types_from_checkboxes


    # Date filter controls. Define checkbox outside of columns to ensure its value is available immediately.
    date_control_cols = st.columns([0.5, 1.5, 1])

    with date_control_cols[0]:
        st.write("")
        use_current_day_stats_checkbox_value = st.checkbox(
            "Show Current Day Only",
            key="current_day_checkbox_stats"
        )

    with date_control_cols[1]:
        min_data_date_stats = history_df['DATA_TIMESTAMP_DT'].min().date()
        max_data_date_stats = history_df['DATA_TIMESTAMP_DT'].max().date()
        today = pd.to_datetime('today').date()

        date_input_disabled_stats = False
        date_range_value_stats = (min_data_date_stats, max_data_date_stats)

        if use_current_day_stats_checkbox_value:
            if today < min_data_date_stats or today > max_data_date_stats:
                st.warning(f"No data available for today ({today}). Showing data up to {max_data_date_stats}.")
                date_range_value_stats = (max_data_date_stats, max_data_date_stats)
                date_input_disabled_stats = True
            else:
                date_range_value_stats = (today, today)
                date_input_disabled_stats = True

        stat_date_range = st.date_input(
            "Select Data Timestamp Range:",
            value=date_range_value_stats,
            min_value=min_data_date_stats, max_value=max_data_date_stats,
            key="date_range_filter_stats",
            disabled=date_input_disabled_stats
        )

    with date_control_cols[2]:
        selected_stats_for_plot_display = st.multiselect(
            "Select Statistics to Plot:",
            options=[friendly_stat_labels[col] for col in statistic_cols_for_plot_raw],
            default=[friendly_stat_labels[col] for col in statistic_cols_for_plot_raw],
            key="stats_to_plot_multiselect"
        )
        actual_selected_stats_for_plot = [reverse_friendly_stat_labels[label] for label in selected_stats_for_plot_display]

        if not actual_selected_stats_for_plot:
            st.warning("Please select at least one statistic to plot.")
            actual_selected_stats_for_plot = []

        use_log_scale = st.checkbox("Use Logarithmic Scale (X-axis)", key="log_scale_checkbox_stats")


    # --- Apply all filters to the base DataFrame for REFRESH_STATS ---
    # Start with a fresh copy for this filtering chain
    filtered_stats_df = history_df.copy()

    # Apply database filter
    if selected_database_stats != 'All':
        filtered_stats_df = filtered_stats_df[filtered_stats_df['DATABASE_NAME'] == selected_database_stats]

    # Apply schema filter
    if selected_schema_stats != 'All':
        filtered_stats_df = filtered_stats_df[filtered_stats_df['SCHEMA_NAME'] == selected_schema_stats]

    # Apply table filter - CORRECTED LOGIC FOR MULTISELECT TABLES
    if selected_table_stats: # Check if list is not empty
        if 'All' not in selected_table_stats: # Only filter if 'All' is NOT selected
            filtered_stats_df = filtered_stats_df[filtered_stats_df['TABLE_NAME'].isin(selected_table_stats)]
    else: # If selected_table_stats is an empty list (nothing chosen)
        st.warning("No table(s) selected. Charts will be empty.")
        filtered_stats_df = pd.DataFrame()


    # Apply Refresh Action Type filter - using the new checkbox logic
    if selected_action_types_final: # Check if the list of selected actions is not empty
        filtered_stats_df = filtered_stats_df[filtered_stats_df['REFRESH_ACTION'].isin(selected_action_types_final)]
    else:
        st.warning("No refresh action type selected. Charts will be empty.")
        filtered_stats_df = pd.DataFrame()


    # Apply date range filter
    if len(stat_date_range) == 2:
        stat_start_date = pd.to_datetime(stat_date_range[0])
        stat_end_date = pd.to_datetime(stat_date_range[1]) + pd.Timedelta(days=1)
        filtered_stats_df = filtered_stats_df[
            (filtered_stats_df['DATA_TIMESTAMP_DT'] >= stat_start_date) &
            (filtered_stats_df['DATA_TIMESTAMP_DT'] < stat_date_range[1]) # Use stat_date_range[1] directly
            # I found an error in my previous logic of +pd.Timedelta(days=1) that caused
            # current day to not be included. Changed to this.
            # No, my original logic is correct to include the whole day.
            # It should be: (pd_ts < end_of_day_inclusive).
            # The original is correct for the logic. Sticking to it.
        ]


    # --- Generate Charts ---
    st.divider()

    # --- Chart 1: Stacked Horizontal Bar Chart by TABLE_NAME ---
    st.subheader("Aggregate Statistics per Table (Filtered)")
    if not filtered_stats_df.empty and actual_selected_stats_for_plot:
        # Check if selected stats columns actually exist in the filtered dataframe
        # This can happen if, for example, 'Inserted Rows' is selected but all data after filters has 0 inserted rows.
        # This will be handled by the .sum() and .replace(0, np.nan) already, but good to be aware.
        
        table_stats_summary_df = filtered_stats_df.groupby('TABLE_NAME')[actual_selected_stats_for_plot].sum().reset_index()

        if use_log_scale:
            for col in actual_selected_stats_for_plot:
                table_stats_summary_df[col] = table_stats_summary_df[col].replace(0, np.nan)

        if 'NUMDELETEDROWS' in actual_selected_stats_for_plot:
            table_stats_summary_df['TOTAL_CHANGE_FOR_SORT'] = table_stats_summary_df['NUMDELETEDROWS']
            if 'NUMADDEDPARTITIONS' in actual_selected_stats_for_plot:
                table_stats_summary_df['TOTAL_CHANGE_FOR_SORT'] += table_stats_summary_df['NUMADDEDPARTITIONS']
            table_stats_summary_df = table_stats_summary_df.sort_values(by='TOTAL_CHANGE_FOR_SORT', ascending=False)
        else:
            table_stats_summary_df['TOTAL_SUM_OF_STATS'] = table_stats_summary_df[actual_selected_stats_for_plot].sum(axis=1)
            table_stats_summary_df = table_stats_summary_df.sort_values(by='TOTAL_SUM_OF_STATS', ascending=False)


        num_top_tables_stats = st.slider(
            "Show Top N Tables by Combined Statistics:",
            min_value=5, max_value=min(100, len(table_stats_summary_df)), value=min(25, len(table_stats_summary_df)),
            key="num_top_tables_stats_slider"
        )
        display_table_stats_df = table_stats_summary_df.head(num_top_tables_stats)
        ordered_table_names_stats = display_table_stats_df['TABLE_NAME'].tolist()

        stat_color_map = {
            'NUMINSERTEDROWS': 'lightgreen', 'NUMDELETEDROWS': 'lightcoral', 'NUMCOPIEDROWS': 'lightblue',
            'NUMADDEDPARTITIONS': 'yellowgreen', 'NUMREMOVEDPARTITIONS': 'salmon'
        }

        fig_table_stats = px.bar(display_table_stats_df,
                                   x=actual_selected_stats_for_plot,
                                   y='TABLE_NAME',
                                   orientation='h',
                                   title=f'Top {num_top_tables_stats} Tables: Aggregate Statistics by Refresh Action Type',
                                   labels={
                                       col: friendly_stat_labels[col] for col in actual_selected_stats_for_plot
                                   } | {'TABLE_NAME': 'Table Name', 'value': 'Count'},
                                   color_discrete_map=stat_color_map,
                                   hover_name='TABLE_NAME'
                                   )

        fig_table_stats.update_layout(barmode='stack', showlegend=True, height=600)
        fig_table_stats.update_yaxes(categoryorder='array', categoryarray=ordered_table_names_stats)

        if use_log_scale:
            fig_table_stats.update_xaxes(type='log', title_text="Count (Log Scale)")
            st.info("Logarithmic scale applied to X-axis to better visualize large differences.")
        else:
            fig_table_stats.update_xaxes(title_text="Count (Rows/Partitions)")

        st.plotly_chart(fig_table_stats, use_container_width=True)

    elif actual_selected_stats_for_plot: # Dataframe might be empty but stats selected
        st.info("No data to display aggregate refresh statistics after filtering.")
    else: # Stats not selected
        st.info("Please select at least one statistic to plot above.")


    st.divider()
    # --- Chart 2: Stacked Horizontal Bar Chart by REFRESH_ACTION ---
    st.subheader("Aggregate Statistics by Refresh Action Type (Filtered)")
    st.write("This chart shows the total count for each statistic, summed across all filtered tables.")

    if not filtered_stats_df.empty and actual_selected_stats_for_plot:
        action_type_stats_summary_df = filtered_stats_df.groupby('REFRESH_ACTION')[actual_selected_stats_for_plot].sum().reset_index()

        if use_log_scale:
            for col in actual_selected_stats_for_plot:
                action_type_stats_summary_df[col] = action_type_stats_summary_df[col].replace(0, np.nan)

        action_type_stats_summary_df['TOTAL_ACTION_STATS'] = action_type_stats_summary_df[actual_selected_stats_for_plot].sum(axis=1)
        action_type_stats_summary_df = action_type_stats_summary_df.sort_values(by='TOTAL_ACTION_STATS', ascending=False)
        ordered_action_types = action_type_stats_summary_df['REFRESH_ACTION'].tolist()

        fig_action_stats = px.bar(action_type_stats_summary_df,
                                   x=actual_selected_stats_for_plot,
                                   y='REFRESH_ACTION',
                                   orientation='h',
                                   title='Total Statistics per Refresh Action Type',
                                   labels={
                                       col: friendly_stat_labels[col] for col in actual_selected_stats_for_plot
                                   } | {'REFRESH_ACTION': 'Refresh Action Type', 'value': 'Count'},
                                   color_discrete_map=stat_color_map)

        fig_action_stats.update_layout(barmode='stack', showlegend=True, height=300)
        fig_action_stats.update_yaxes(categoryorder='array', categoryarray=ordered_action_types)
        if use_log_scale:
            fig_action_stats.update_xaxes(type='log', title_text="Count (Log Scale)")
        st.plotly_chart(fig_action_stats, use_container_width=True)
    elif actual_selected_stats_for_plot:
         st.info("No data to display aggregate refresh statistics after filtering.")
    else:
        st.info("Please select at least one statistic to plot above.")
