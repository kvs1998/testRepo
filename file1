with tab_dt_state:
    st.header("Dynamic Table Refresh History & Analysis")

    if history_df.empty:
        st.warning("No data loaded from Snowflake. Please ensure data is available.")
        st.stop()

    st.subheader("Filter Table Refresh History:")
    filter_cols_top = st.columns([1, 1, 1, 0.7])

    with filter_cols_top[0]:
        all_databases = ['All'] + sorted(history_df['DATABASE_NAME'].unique().tolist())
        selected_database = st.selectbox(
            "Filter by Database:", options=all_databases, key="db_filter_dt"
        )

    with filter_cols_top[1]:
        if selected_database != 'All':
            current_db_schemas = history_df[history_df['DATABASE_NAME'] == selected_database]['SCHEMA_NAME'].unique().tolist()
            schemas_in_db = ['All'] + sorted(current_db_schemas)
        else:
            schemas_in_db = ['All'] + sorted(history_df['SCHEMA_NAME'].unique().tolist())
        selected_schema = st.selectbox(
            "Filter by Schema:", options=schemas_in_db, key="schema_filter_dt"
        )

    filtered_df_for_table_select_options_dt = history_df.copy()
    if selected_database != 'All':
        filtered_df_for_table_select_options_dt = filtered_df_for_table_select_options_dt[filtered_df_for_table_select_options_dt['DATABASE_NAME'] == selected_database]
    if selected_schema != 'All':
        filtered_df_for_table_select_options_dt = filtered_df_for_table_select_options_dt[filtered_df_for_table_select_options_dt['SCHEMA_NAME'] == selected_schema]

    with filter_cols_top[2]:
        if not filtered_df_for_table_select_options_dt.empty:
            all_tables_dt_options = ['All'] + sorted(filtered_df_for_table_select_options_dt['TABLE_NAME'].unique().tolist())
            default_tables_selected_dt = ['All']
        else:
            all_tables_dt_options = ['All']
            default_tables_selected_dt = ['All']
            st.info("No tables found for selected Database/Schema combination.")
        selected_table_dt = st.multiselect(
            "Filter by Table(s):",
            options=all_tables_dt_options,
            default=default_tables_selected_dt,
            key="table_filter_dt_multi"
        )

    with filter_cols_top[3]:
        all_states = ['All'] + sorted(history_df['STATE'].unique().tolist())
        selected_states = st.multiselect(
            "Select States to Display:", options=all_states, default=all_states,
            help="Select which refresh states to include in the stacked bar chart.",
            key="state_multi_select_dt"
        )

    # Date filter controls
    date_checkbox_col_dt, date_input_col_dt = st.columns([0.5, 1.5])
    with date_checkbox_col_dt:
        st.write("")
        use_current_day_dt = st.checkbox("Show Current Day Only", key="current_day_checkbox_dt")

    with date_input_col_dt:
        min_data_date_dt = history_df['DATA_TIMESTAMP_DT'].min().date()
        max_data_date_dt = history_df['DATA_TIMESTAMP_DT'].max().date()
        today = pd.to_datetime('today').date()

        date_input_disabled_dt = False
        date_range_value_dt = (min_data_date_dt, max_data_date_dt)

        if use_current_day_dt:
            if max_data_date_dt >= today:
                date_range_value_dt = (today, today)
            else:
                st.warning(f"No data available for today ({today}). Showing data up to {max_data_date_dt}.")
                date_range_value_dt = (max_data_date_dt, max_data_date_dt)
            date_input_disabled_dt = True

        date_range_dt = st.date_input(
            "Select Data Timestamp Range:",
            value=date_range_value_dt, min_value=min_data_date_dt, max_data_date_dt,
            key="date_range_filter_dt", disabled=date_input_disabled_dt
        )

    st.write("") # Spacer below the date filter for problem checkbox
    show_problem_tables_only = st.checkbox(
        "Show only tables with past FAILED/UPSTREAM_FAILED states",
        key="problem_tables_checkbox_dt"
    )

    # --- Apply all filters to the base DataFrame for DT STATE ---
    filtered_history_df_dt = history_df.copy()

    if selected_database != 'All':
        filtered_history_df_dt = filtered_history_df_dt[filtered_history_df_dt['DATABASE_NAME'] == selected_database]
    if selected_schema != 'All':
        filtered_history_df_dt = filtered_history_df_dt[filtered_history_df_dt['SCHEMA_NAME'] == selected_schema]

    if selected_table_dt and 'All' not in selected_table_dt:
        filtered_history_df_dt = filtered_history_df_dt[filtered_history_df_dt['TABLE_NAME'].isin(selected_table_dt)]
    elif not selected_table_dt:
        st.warning("No table(s) selected by filters. Display will be empty.")
        filtered_history_df_dt = pd.DataFrame()

    if selected_states and 'All' not in selected_states:
        filtered_history_df_dt = filtered_history_df_dt[filtered_history_df_dt['STATE'].isin(selected_states)]
    elif not selected_states:
        st.warning("No state(s) selected. Charts/Table will be empty.")
        filtered_history_df_dt = pd.DataFrame()

    if show_problem_tables_only:
        problem_tables_all_time = history_df[history_df['STATE'].isin(["FAILED", "UPSTREAM_FAILED"])]['TABLE_NAME'].unique()
        if problem_tables_all_time.size > 0:
            if not filtered_history_df_dt.empty:
                filtered_history_df_dt = filtered_history_df_dt[filtered_history_df_dt['TABLE_NAME'].isin(problem_tables_all_time)]
            else:
                st.info("No tables with FAILED/UPSTREAM_FAILED history found in the full dataset for this filter.")
        else:
            st.info("No tables with FAILED/UPSTREAM_FAILED history in the original dataset.")
            filtered_history_df_dt = pd.DataFrame()

    if len(date_range_dt) == 2:
        start_date_dt = pd.to_datetime(date_range_dt[0])
        end_date_dt = pd.to_datetime(date_range_dt[1]) + pd.Timedelta(days=1)
        if not filtered_history_df_dt.empty:
            filtered_history_df_dt = filtered_history_df_dt[
                (filtered_history_df_dt['DATA_TIMESTAMP_DT'] >= start_date_dt) &
                (filtered_history_df_dt['DATA_TIMESTAMP_DT'] < end_date_dt)
            ]
        if filtered_history_df_dt.empty:
             st.info("No data found for the selected date range after other filters have been applied.")


    # --- Display Filtered Table (DT STATE) ---
    st.divider()
    table_header_cols_dt = st.columns([0.7, 0.3])
    with table_header_cols_dt[0]:
        st.subheader("Filtered Raw Data (Table View)")
    with table_header_cols_dt[1]:
        st.write("")
        show_latest_table_data_dt = st.checkbox("Show Latest Data Only", key="latest_table_data_checkbox_dt")

    dt_table_display_columns_raw = [
        'TABLE_NAME', 'STATE', 'STATE_MESSAGE', 'DATA_TIMESTAMP',
        'REFRESH_START_TIME', 'REFRESH_END_TIME', 'COMPLETITION_TARGET', 'TARGET_LAG_SEC'
    ]

    if not filtered_history_df_dt.empty:
        df_for_dt_table = filtered_history_df_dt.copy()

        if show_latest_table_data_dt:
            idx_dt_table = df_for_dt_table.groupby('TABLE_NAME')['DATA_TIMESTAMP_DT'].idxmax()
            df_for_dt_table = df_for_dt_table.loc[idx_dt_table]
            st.info("Displaying only the latest refresh entry for each table.")

        # Ensure all columns are present before selecting (handle if any were dropped earlier)
        df_for_dt_table_final = df_for_dt_table[
            [col for col in dt_table_display_columns_raw if col in df_for_dt_table.columns]
        ]
        
        # Removed multi-column sort controls and logic from here
        st.dataframe(df_for_dt_table_final, use_container_width=True)
    else:
        st.info("No data to display in the table based on current filters. Adjust filter selections.")

    st.divider()

    # --- Chart 1: Stacked Horizontal Bar Chart by TABLE_NAME (DT STATE) ---
    st.subheader("Historical State Counts per Table")
    st.write("This chart shows the historical count of each state for individual tables, based on applied filters.")

    if not filtered_history_df_dt.empty:
        table_state_counts = filtered_history_df_dt.groupby(['TABLE_NAME', 'STATE']).size().reset_index(name='COUNT')
        pivot_df = table_state_counts.pivot_table(index='TABLE_NAME', columns='STATE', values='COUNT').fillna(0).reset_index()
        all_possible_states = ["SCHEDULED", "EXECUTING", "SUCCEEDED", "FAILED", "CANCELLED", "UPSTREAM_FAILED"]
        for state in all_possible_states:
            if state not in pivot_df.columns:
                pivot_df[state] = 0
        stack_order_for_plot = [s for s in all_possible_states if s in selected_states]
        if not stack_order_for_plot: st.info("No states selected to display."); pivot_df = pd.DataFrame()

        if not pivot_df.empty:
            pivot_df['TOTAL_REFRESHES'] = pivot_df[all_possible_states].sum(axis=1)
            pivot_df['FAILED_COUNT_FOR_SORT'] = pivot_df['FAILED'] + pivot_df['UPSTREAM_FAILED']
            pivot_df = pivot_df.sort_values(by=['FAILED_COUNT_FOR_SORT', 'TOTAL_REFRESHES'], ascending=[False, False])
            num_top_tables = st.slider("Show Top N Tables (by FAILED/UPSTREAM_FAILED then Total Refreshes):", min_value=5, max_value=min(100, len(pivot_df)), value=min(25, len(pivot_df)), key="state_history_table_slider_dt")
            display_pivot_df = pivot_df.head(num_top_tables)
            ordered_table_names = display_pivot_df['TABLE_NAME'].tolist()

            fig_table_states = px.bar(display_pivot_df, x=stack_order_for_plot, y='TABLE_NAME', orientation='h', title=f'Historical State Counts for Top {num_top_tables} Tables (Filtered)', labels={'value': 'Count', 'TABLE_NAME': 'Table Name', 'variable': 'State'}, color_discrete_map={"FAILED": "red", "UPSTREAM_FAILED": "darkred", "CANCELLED": "orange", "SCHEDULED": "blue", "EXECUTING": "purple", "SUCCEEDED": "green"}, hover_name='TABLE_NAME')
            fig_table_states.update_layout(barmode='stack', showlegend=True, height=600)
            fig_table_states.update_yaxes(categoryorder='array', categoryarray=ordered_table_names)
            st.plotly_chart(fig_table_states, use_container_width=True)
        else: st.info("No data for cumulative state counts chart after filtering.")
    else: st.info("No data available for cumulative state counts chart after filters.")

    # --- Overall Distribution of Dynamic Table States (Chart 2) ---
    st.header("Overall Distribution of Dynamic Table States")
    if not filtered_history_df_dt.empty:
        state_counts = filtered_history_df_dt['STATE'].value_counts().reset_index()
        state_counts.columns = ['STATE', 'COUNT']
        state_order = ["FAILED", "UPSTREAM_FAILED", "CANCELLED", "SCHEDULED", "EXECUTING", "SUCCEEDED"]
        state_counts['STATE'] = pd.Categorical(state_counts['STATE'], categories=[s for s in state_order if s in state_counts['STATE'].unique()], ordered=True)
        state_counts = state_counts.sort_values('STATE')

        fig_bar_states = px.bar(state_counts, x='COUNT', y='STATE', orientation='h', title='Number of Tables per Refresh State (Filtered)', color='STATE', color_discrete_map={"FAILED": "red", "UPSTREAM_FAILED": "darkred", "CANCELLED": "orange", "SCHEDULED": "blue", "EXECUTING": "purple", "SUCCEEDED": "green"})
        fig_bar_states.update_layout(showlegend=False)
        fig_bar_states.update_yaxes(categoryorder="array", categoryarray=state_counts['STATE'].tolist()[::-1])
        st.plotly_chart(fig_bar_states, use_container_width=True)
    else: st.info("No data to display overall state distribution after filtering.")

    # --- KPI Summary (Chart 3) ---
    st.subheader("Key Refresh Status Summary (for quick glance)")
    if not filtered_history_df_dt.empty:
        state_counts_kpi = filtered_history_df_dt['STATE'].value_counts()
        total_tables_kpi = state_counts_kpi.sum()

        col_failed_kpi, col_succeeded_kpi, col_executing_kpi = st.columns(3)
        with col_failed_kpi:
            failed_count_kpi = state_counts_kpi.get("FAILED", 0) + state_counts_kpi.get("UPSTREAM_FAILED", 0)
            st.metric(label="<span style='color:red;'>Total Failed/Upstream Failed</span>", value=f"{failed_count_kpi} tables", delta=f"{failed_count_kpi/total_tables_kpi:.1%}" if total_tables_kpi > 0 else "0.0%", delta_color="inverse")
        with col_succeeded_kpi:
            succeeded_count_kpi = state_counts_kpi.get("SUCCEEDED", 0)
            st.metric(label="<span style='color:green;'>Succeeded</span>", value=f"{succeeded_count_kpi} tables", delta=f"{succeeded_count_kpi/total_tables_kpi:.1%}" if total_tables_kpi > 0 else "0.0%", delta_color="normal")
        with col_executing_kpi:
            executing_count_kpi = state_counts_kpi.get("EXECUTING", 0)
            st.metric(label="<span style='color:purple;'>Executing</span>", value=f"{executing_count_kpi} tables")
    else: st.info("No data for KPI summary after filtering.")
