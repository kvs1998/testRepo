CREATE OR REPLACE PROCEDURE YOUR_DB.YOUR_SCHEMA.SP_DRIVE_ALL_DT_COLLECTION()
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS
$$
DECLARE
    -- --- Configuration Variables ---
    LV_TRACKING_TABLE_FQDN VARCHAR := 'YOUR_DB.YOUR_SCHEMA.T_DYNAMIC_TABLE_TRACKING';
    LV_REFRESH_HISTORY_PROC_FQDN VARCHAR := 'YOUR_DB.YOUR_SCHEMA.SP_COLLECT_DT_REFRESH_HISTORY';
    LV_METADATA_PROC_FQDN VARCHAR := 'YOUR_DB.YOUR_SCHEMA.SP_COLLECT_DYNAMIC_TABLE_METADATA';
    
    -- --- Internal Variables ---
    lv_message VARCHAR DEFAULT '';
    lv_total_tables_found INTEGER DEFAULT 0;
    lv_jobs_submitted_count INTEGER DEFAULT 0;
    lv_overall_success_count INTEGER DEFAULT 0;
    lv_overall_fail_count INTEGER DEFAULT 0;
    lv_db_name VARCHAR;
    lv_schema_name VARCHAR;
    lv_table_name VARCHAR;
    lv_qualified_name VARCHAR;
    lv_track_refresh_history BOOLEAN;
    lv_track_metadata_snapshot BOOLEEN;
    lv_track_graph_history BOOLEAN; -- Not implemented yet, but included in schema
    lv_refresh_history_days NUMBER;
    lv_metadata_days NUMBER;
    lv_sub_proc_query_id VARCHAR; -- To store the QUERY_ID of ASYNC calls
    lv_proc_execution_status VARCHAR; -- Status from QUERY_HISTORY
    lv_proc_return_value VARCHAR;     -- Actual RETURN value from the sub-procedure
    lv_proc_error_message VARCHAR;    -- Error message from QUERY_HISTORY if failed
    lv_loop_error_message VARCHAR;
    
    lv_job_db_name VARCHAR; -- NEW: To store the database name for the current job being polled

    -- Cursor to select active tables needing collection
    c_tables CURSOR FOR
        SELECT 
            DATABASE_NAME, SCHEMA_NAME, TABLE_NAME, QUALIFIED_NAME,
            TRACK_REFRESH_HISTORY, TRACK_METADATA_SNAPSHOT, TRACK_GRAPH_HISTORY,
            COLLECT_REFRESH_HISTORY_DAYS, COLLECT_METADATA_DAYS
        FROM IDENTIFIER(:LV_TRACKING_TABLE_FQDN)
        WHERE IS_ACTIVE = TRUE;

BEGIN
    lv_message := lv_message || 'Starting DYNAMIC TABLE COLLECTION DRIVER at ' || CURRENT_TIMESTAMP() || '\n';
    
    -- Create temporary table to log ASYNC jobs submitted
    CREATE OR REPLACE TEMPORARY TABLE ASYNC_JOB_QUEUE (
        QUALIFIED_NAME VARCHAR,
        JOB_TYPE VARCHAR, -- 'REFRESH_HISTORY' or 'METADATA_SNAPSHOT'
        QUERY_ID VARCHAR PRIMARY KEY,
        SUBMISSION_TIME TIMESTAMP_LTZ
    );

    -- --- Step 1: Launch all ASYNC jobs ---
    OPEN c_tables;
    LOOP
        FETCH c_tables INTO lv_db_name, lv_schema_name, lv_table_name, lv_qualified_name,
                             lv_track_refresh_history, lv_track_metadata_snapshot, lv_track_graph_history,
                             lv_refresh_history_days, lv_metadata_days;
        IF (c_tables%NOTFOUND) THEN
            BREAK; -- Exit loop when no more records
        END IF;

        lv_total_tables_found := lv_total_tables_found + 1;

        BEGIN -- Inner BEGIN/END block for per-table ASYNC job submission error handling
            
            -- Call SP_COLLECT_DT_REFRESH_HISTORY ASYNC
            IF (lv_track_refresh_history) THEN
                EXECUTE IMMEDIATE 'CALL ' || :LV_REFRESH_HISTORY_PROC_FQDN || '(?, ?, ?, ?) ASYNC'
                USING lv_db_name, lv_schema_name, lv_table_name, lv_refresh_history_days;
                
                lv_sub_proc_query_id := LAST_QUERY_ID();
                INSERT INTO ASYNC_JOB_QUEUE (QUALIFIED_NAME, JOB_TYPE, QUERY_ID, SUBMISSION_TIME)
                VALUES (:lv_qualified_name, 'REFRESH_HISTORY', :lv_sub_proc_query_id, CURRENT_TIMESTAMP());
                lv_jobs_submitted_count := lv_jobs_submitted_count + 1;
                lv_message := lv_message || '  Submitted Refresh History for ' || lv_qualified_name || ' (Query ID: ' || lv_sub_proc_query_id || ')\n';
            END IF;

            -- Call SP_COLLECT_DYNAMIC_TABLE_METADATA ASYNC
            IF (lv_track_metadata_snapshot) THEN
                EXECUTE IMMEDIATE 'CALL ' || :LV_METADATA_PROC_FQDN || '(?, ?, ?) ASYNC'
                USING lv_db_name, lv_schema_name, lv_table_name;

                lv_sub_proc_query_id := LAST_QUERY_ID();
                INSERT INTO ASYNC_JOB_QUEUE (QUALIFIED_NAME, JOB_TYPE, QUERY_ID, SUBMISSION_TIME)
                VALUES (:lv_qualified_name, 'METADATA_SNAPSHOT', :lv_sub_proc_query_id, CURRENT_TIMESTAMP());
                lv_jobs_submitted_count := lv_jobs_submitted_count + 1;
                lv_message := lv_message || '  Submitted Metadata Snapshot for ' || lv_qualified_name || ' (Query ID: ' || lv_sub_proc_query_id || ')\n';
            END IF;

        EXCEPTION
            WHEN OTHER THEN
                lv_loop_error_message := 'ERROR submitting ASYNC job(s) for ' || lv_qualified_name || ': ' || SQLERRM();
                lv_message := lv_message || '    ' || lv_loop_error_message || '\n';
                -- If submission fails, log it as an immediate failure.
                INSERT INTO ASYNC_JOB_QUEUE (QUALIFIED_NAME, JOB_TYPE, QUERY_ID, SUBMISSION_TIME, STATUS, MESSAGE, LAST_UPDATE_TIME)
                VALUES (:lv_qualified_name, 'SUBMISSION_FAILED_UNKNOWN_TYPE', 'N/A_SUB_ERROR', CURRENT_TIMESTAMP(), 'FAILED_SUBMISSION', :lv_loop_error_message, CURRENT_TIMESTAMP());
        END; -- End inner BEGIN/END block for submission
    END LOOP;
    CLOSE c_tables;

    lv_message := lv_message || 'All ASYNC jobs submitted (' || lv_jobs_submitted_count || ' jobs). Waiting for completion...\n';

    -- --- Step 2: Poll and wait for all submitted ASYNC jobs to complete and process results ---
    FOR job_row IN (SELECT QUALIFIED_NAME, JOB_TYPE, QUERY_ID FROM ASYNC_JOB_QUEUE) DO
        BEGIN
            -- Extract database name from QUALIFIED_NAME for querying Information Schema
            lv_job_db_name := SPLIT_PART(job_row.QUALIFIED_NAME, '.', 1);

            -- Wait for the specific ASYNC job to complete
            CALL SYSTEM$WAIT_FOR_JOB(job_row.QUERY_ID, 7200); -- Wait up to 2 hours (7200 seconds)
            
            -- Dynamically construct and execute the query against the specific database's INFORMATION_SCHEMA.QUERY_HISTORY
            EXECUTE IMMEDIATE '
                SELECT 
                    qh.EXECUTION_STATUS, 
                    qh.RETURN_VALUE::VARCHAR,
                    qh.ERROR_MESSAGE
                FROM IDENTIFIER(:1):INFORMATION_SCHEMA.QUERY_HISTORY() qh -- CORRECTED: Dynamically qualify INFORMATION_SCHEMA
                WHERE qh.QUERY_ID = :2
                QUALIFY ROW_NUMBER() OVER (PARTITION BY qh.QUERY_ID ORDER BY qh.START_TIME DESC) = 1'
            USING lv_job_db_name, job_row.QUERY_ID -- Pass db name and query_id as bind variables
            INTO lv_proc_execution_status, lv_proc_return_value, lv_proc_error_message;
            
            -- Default to a message if RETURN_VALUE is NULL (e.g., if the SP had no explicit RETURN)
            lv_proc_return_value := COALESCE(lv_proc_return_value, 'No specific return message from procedure.');

            -- Update the temporary log table with the final status and message
            IF (lv_proc_execution_status = 'SUCCESS') THEN
                UPDATE ASYNC_JOB_QUEUE 
                SET STATUS = 'SUCCEEDED', MESSAGE = :lv_proc_return_value, LAST_UPDATE_TIME = CURRENT_TIMESTAMP()
                WHERE QUERY_ID = job_row.QUERY_ID;
                
                -- --- Update T_DYNAMIC_TABLE_TRACKING based on success ---
                IF (job_row.JOB_TYPE = 'REFRESH_HISTORY') THEN
                    UPDATE IDENTIFIER(:LV_TRACKING_TABLE_FQDN)
                    SET 
                        LAST_REFRESH_HISTORY_COLLECTION_TIMESTAMP = CURRENT_TIMESTAMP()::TIMESTAMP_NTZ,
                        LAST_REFRESH_HISTORY_COLLECTION_STATUS = 'SUCCESS',
                        LAST_REFRESH_HISTORY_COLLECTION_MESSAGE = :lv_proc_return_value,
                        UPDATED_AT = CURRENT_TIMESTAMP()::TIMESTAMP_NTZ
                    WHERE QUALIFIED_NAME = job_row.QUALIFIED_NAME;
                ELSIF (job_row.JOB_TYPE = 'METADATA_SNAPSHOT') THEN
                     UPDATE IDENTIFIER(:LV_TRACKING_TABLE_FQDN)
                    SET 
                        LAST_METADATA_COLLECTION_TIMESTAMP = CURRENT_TIMESTAMP()::TIMESTAMP_NTZ,
                        LAST_METADATA_COLLECTION_STATUS = 'SUCCESS',
                        LAST_METADATA_COLLECTION_MESSAGE = :lv_proc_return_value,
                        UPDATED_AT = CURRENT_TIMESTAMP()::TIMESTAMP_NTZ
                    WHERE QUALIFIED_NAME = job_row.QUALIFIED_NAME;
                END IF;

            ELSE -- Job failed, cancelled, or timed out during execution
                -- Prioritize explicit error_message from QUERY_HISTORY if available, else use procedure's return, else generic
                lv_proc_error_message := COALESCE(lv_proc_error_message, lv_proc_return_value, 'Unknown execution failure/timeout');

                UPDATE ASYNC_JOB_QUEUE 
                SET STATUS = :lv_proc_execution_status, MESSAGE = :lv_proc_error_message, LAST_UPDATE_TIME = CURRENT_TIMESTAMP()
                WHERE QUERY_ID = job_row.QUERY_ID;

                -- --- Update T_DYNAMIC_TABLE_TRACKING based on failure ---
                 IF (job_row.JOB_TYPE = 'REFRESH_HISTORY') THEN
                    UPDATE IDENTIFIER(:LV_TRACKING_TABLE_FQDN)
                    SET 
                        LAST_REFRESH_HISTORY_COLLECTION_TIMESTAMP = CURRENT_TIMESTAMP()::TIMESTAMP_NTZ,
                        LAST_REFRESH_HISTORY_COLLECTION_STATUS = 'FAILED',
                        LAST_REFRESH_HISTORY_COLLECTION_MESSAGE = :lv_proc_error_message,
                        UPDATED_AT = CURRENT_TIMESTAMP()::TIMESTAMP_NTZ
                    WHERE QUALIFIED_NAME = job_row.QUALIFIED_NAME;
                ELSIF (job_row.JOB_TYPE = 'METADATA_SNAPSHOT') THEN
                     UPDATE IDENTIFIER(:LV_TRACKING_TABLE_FQDN)
                    SET 
                        LAST_METADATA_COLLECTION_TIMESTAMP = CURRENT_TIMESTAMP()::TIMESTAMP_NTZ,
                        LAST_METADATA_COLLECTION_STATUS = 'FAILED',
                        LAST_METADATA_COLLECTION_MESSAGE = :lv_proc_error_message,
                        UPDATED_AT = CURRENT_TIMESTAMP()::TIMESTAMP_NTZ
                    WHERE QUALIFIED_NAME = job_row.QUALIFIED_NAME;
                END IF;
            END IF;

        EXCEPTION
            WHEN OTHER THEN
                lv_loop_error_message := 'Polling/Result retrieval ERROR for ' || job_row.QUALIFIED_NAME || ' ' || job_row.JOB_TYPE || ' (Query ID: ' || job_row.QUERY_ID || '): ' || SQLERRM();
                lv_message := lv_message || '    ' || lv_loop_error_message || '\n';
                UPDATE ASYNC_JOB_QUEUE 
                SET STATUS = 'FAILED_POLLING', MESSAGE = :lv_loop_error_message, LAST_UPDATE_TIME = CURRENT_TIMESTAMP()
                WHERE QUERY_ID = job_row.QUERY_ID;
        END;
    END FOR; -- End of polling loop

    -- --- Step 3: Final Summary and Return ---
    lv_message := lv_message || 'DYNAMIC TABLE COLLECTION DRIVER finished at ' || CURRENT_TIMESTAMP() || '\n';
    
    -- Recalculate processed/success/fail counts from ASYNC_JOB_QUEUE to be fully accurate
    SELECT COUNT(*) INTO lv_jobs_submitted_count FROM ASYNC_JOB_QUEUE; -- Total attempts to run a job from queue
    SELECT COUNT(*) INTO lv_overall_success_count FROM ASYNC_JOB_QUEUE WHERE STATUS = 'SUCCEEDED';
    SELECT COUNT(*) INTO lv_overall_fail_count FROM ASYNC_JOB_QUEUE WHERE STATUS NOT LIKE 'SUCCEEDED%'; -- Any status other than succeeded
    
    lv_message := lv_message || 'Total tables in tracking: ' || lv_total_tables_found || '\n';
    lv_message := lv_message || 'Total ASYNC Jobs attempted: ' || lv_jobs_submitted_count || '\n';
    lv_message := lv_message || 'Jobs Overall Success: ' || lv_overall_success_count || '\n';
    lv_message := lv_message || 'Jobs Overall Failed: ' || lv_overall_fail_count || '\n';
    
    -- Add summary of job results from ASYNC_JOB_QUEUE for detailed logs
    lv_message := lv_message || '\n--- ASYNC Job Individual Results ---\n';
    FOR result_row IN (SELECT QUALIFIED_NAME, JOB_TYPE, STATUS, MESSAGE FROM ASYNC_JOB_QUEUE ORDER BY QUALIFIED_NAME, JOB_TYPE) DO
        lv_message := lv_message || result_row.QUALIFIED_NAME || ' - ' || result_row.JOB_TYPE || ': ' || result_row.STATUS || ' (' || COALESCE(result_row.MESSAGE, '') || ')\n';
    END FOR;

    RETURN lv_message;

EXCEPTION
    WHEN OTHER THEN
        lv_error_message := 'Major Error in DYNAMIC TABLE COLLECTION DRIVER: ' || SQLERRM();
        RETURN lv_error_message;
END;
$$;
