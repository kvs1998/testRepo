# Assuming filtered_history_df and time_format_option are already defined in the scope,
# and format_seconds_to_readable is available.

# --- START OF "Refresh Duration Distribution" Histogram SNIPPET (chart_cols_pair3[0]) ---

with chart_cols_pair3[0]: # Refresh Duration Distribution (Histogram)
    st.markdown("<p style='font-size:16px;'><b>Refresh Duration Distribution</b></p>", unsafe_allow_html=True)
    cols_chart_header = st.columns([0.8, 0.2]) # Internal columns for title and checkbox
    with cols_chart_header[0]:
        st.write("Distribution of refresh durations.")
    with cols_chart_header[1]:
        use_log_scale_duration_hist = st.checkbox("Log Scale X-axis", key="log_scale_duration_hist_dt_state")
    
    if 'REFRESH_DURATION_SEC' in filtered_history_df.columns and not filtered_history_df['REFRESH_DURATION_SEC'].empty:
        # --- APPLY NO_DATA FILTER HERE FOR DURATION ANALYSIS ---
        duration_data_for_hist_df = filtered_history_df[
            filtered_history_df['REFRESH_ACTION'] != 'NO_DATA'
        ].copy()

        if duration_data_for_hist_df.empty:
            st.info("No data available for duration distribution after excluding 'NO_DATA' refreshes. Please adjust filters.", icon="ℹ️")
        else:
            # --- TRANSFORM X-AXIS DATA TO SELECTED DISPLAY UNIT FOR PLOTTING ---
            # Define the divisor based on the selected time_format_option
            if time_format_option == "minutes":
                unit_divisor_hist = 60
            elif time_format_option == "hours":
                unit_divisor_hist = 3600
            elif time_format_option == "days":
                unit_divisor_hist = 86400
            else: # "seconds" or "mixed" (plot in seconds, so divisor is 1)
                unit_divisor_hist = 1
            
            duration_data_for_hist_df['X_AXIS_PLOT_VALUE'] = duration_data_for_hist_df['REFRESH_DURATION_SEC'] / unit_divisor_hist

            # Get the Series of data points to plot for the histogram
            duration_values_to_plot = duration_data_for_hist_df['X_AXIS_PLOT_VALUE'].dropna().copy()
            
            # Filter out non-positive values if log scale is to be applied
            if use_log_scale_duration_hist:
                initial_count_before_log_filter = len(duration_values_to_plot)
                duration_values_to_plot = duration_values_to_plot.apply(lambda x: x if x > 0 else 1e-9)
                if len(duration_values_to_plot) < initial_count_before_log_filter:
                    st.info(f"Note: {initial_count_before_log_filter - len(duration_values_to_plot)} data point(s) with zero/negative values were excluded for log scale histogram display.", icon="ℹ️")


            if not duration_values_to_plot.empty:
                fig_duration_hist = px.histogram(
                    duration_values_to_plot, # Plot the transformed values
                    x=duration_values_to_plot.name, # Use the actual series name
                    nbins=20, # Fixed bins, or could make dynamic based on range
                    labels={duration_values_to_plot.name: f'Duration ({time_format_option})'}, # Dynamic label
                    text_auto=False
                )
                fig_duration_hist.update_layout(bargap=0.1, title_text='') # Remove title

                if use_log_scale_duration_hist:
                    fig_duration_hist.update_xaxes(type='log', rangemode='tozero')
                    st.info("Logarithmic scale applied to X-axis. Zero counts are handled gracefully.", icon="ℹ️")
                
                # --- Dynamic X-axis Tick Formatting for Histogram ---
                # Only apply custom ticks if NOT using log scale (Plotly handles log ticks well)
                if not use_log_scale_duration_hist:
                    min_x_val = fig_duration_hist.layout.xaxis.range[0] if fig_duration_hist.layout.xaxis.range else duration_values_to_plot.min()
                    max_x_val = fig_duration_hist.layout.xaxis.range[1] if fig_duration_hist.layout.xaxis.range else duration_values_to_plot.max()
                    
                    if max_x_val > min_x_val and max_x_val > 0:
                        # Robust tick generation
                        if max_x_val == min_x_val:
                            tick_values_converted_unit = [min_x_val]
                        elif max_x_val - min_x_val < 1e-6 and max_x_val > 0:
                            tick_values_converted_unit = [min_x_val, max_x_val]
                            if len(set(tick_values_converted_unit)) < 2:
                                tick_values_converted_unit.append(min_x_val + (max_x_val - min_x_val) / 2)
                            tick_values_converted_unit = sorted(list(set(tick_values_converted_unit)))
                        else:
                            num_ticks = 5
                            tick_values_converted_unit = np.linspace(min_x_val, max_x_val, num=num_ticks, endpoint=True)
                        
                        # Convert these tick values BACK to seconds for format_seconds_to_readable
                        tick_values_seconds = pd.Series(tick_values_converted_unit) * unit_divisor_hist
                        
                        tick_texts_formatted = format_seconds_to_readable(tick_values_seconds, time_format_option).tolist()
                        
                        fig_duration_hist.update_xaxes(
                            type='linear',
                            tickvals=tick_values_converted_unit,
                            ticktext=tick_texts_formatted
                        )
                    else: # Fallback for very small range or zero
                        fig_duration_hist.update_xaxes(type='linear', tickformat=".1f") # Default Plotly numerical ticks
                            
                st.plotly_chart(fig_duration_hist, use_container_width=True)
            else: # duration_values_to_plot became empty after filtering for log scale or general dropna
                st.info("No refresh duration data to display for histogram after filtering for positive values.", icon="ℹ️")
        # This else-block handles if duration_data_for_hist_df was empty initially (after NO_DATA filter)
        else:
            st.info("No REFRESH_DURATION_SEC data available after excluding 'NO_DATA' refreshes.", icon="ℹ️")

# --- END OF "Refresh Duration Distribution" Histogram SNIPPET ---
