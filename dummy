with chart_cols_pair3[0]: # Refresh Duration Distribution (Histogram)
    st.markdown("<p style='font-size:16px;'><b>Refresh Duration Distribution</b></p>", unsafe_allow_html=True)
    cols_chart_header = st.columns([0.8, 0.2]) # Revert to 2 columns for title and Y-axis checkbox
    with cols_chart_header[0]:
        st.write("Distribution of refresh durations.")
    with cols_chart_header[1]:
        # Only Y-axis log scale checkbox remains for histogram
        use_log_scale_duration_hist_y = st.checkbox("Log Scale Y-axis", key="log_scale_duration_hist_y_dt_state")
        
    if 'REFRESH_DURATION_SEC' in filtered_history_df.columns and not filtered_history_df['REFRESH_DURATION_SEC'].empty:
        # --- APPLY NO_DATA FILTER HERE FOR DURATION ANALYSIS ---
        duration_data_for_hist_df = filtered_history_df[
            filtered_history_df['REFRESH_ACTION'] != 'NO_DATA'
        ].copy()

        if duration_data_for_hist_df.empty:
            st.info("No data available for duration distribution after excluding 'NO_DATA' refreshes. Please adjust filters.", icon="ℹ️")
        else:
            # --- TRANSFORM X-AXIS DATA TO SELECTED DISPLAY UNIT FOR PLOTTING ---
            if time_format_option == "minutes":
                unit_divisor_hist = 60
            elif time_format_option == "hours":
                unit_divisor_hist = 3600
            elif time_format_option == "days":
                unit_divisor_hist = 86400
            else: # "seconds" or "mixed" (plot in seconds, so divisor is 1)
                unit_divisor_hist = 1
            
            duration_data_for_hist_df['X_AXIS_PLOT_VALUE'] = duration_data_for_hist_df['REFRESH_DURATION_SEC'] / unit_divisor_hist

            # Get the Series of data points to plot for the histogram
            duration_values_to_plot = duration_data_for_hist_df['X_AXIS_PLOT_VALUE'].dropna().copy()
            
            # Note: No X-axis log scale to handle, so no related zero-exclusion here.
            # If `use_log_scale_duration_hist_y` is true, Y-axis log scale will handle zeros on COUNT.

            if not duration_values_to_plot.empty:
                fig_duration_hist = px.histogram(
                    duration_values_to_plot, # Plot the transformed values
                    x=duration_values_to_plot.name, # Use the actual series name
                    nbins=20, # Fixed bins, or could make dynamic based on range
                    labels={duration_values_to_plot.name: f'Duration ({time_format_option})'}, # Dynamic label
                    text_auto=False # Don't show text on bars by default
                )
                fig_duration_hist.update_layout(bargap=0.1, title_text='') # Remove title

                # --- X-axis remains linear with dynamic tick formatting ---
                if time_format_option != 'seconds':
                    min_x_val = fig_duration_hist.layout.xaxis.range[0] if fig_duration_hist.layout.xaxis.range else duration_values_to_plot.min()
                    max_x_val = fig_duration_hist.layout.xaxis.range[1] if fig_duration_hist.layout.xaxis.range else duration_values_to_plot.max()
                    
                    if max_x_val > min_x_val and max_x_val > 0:
                        if max_x_val == min_x_val:
                            tick_values_converted_unit = [min_x_val]
                        elif max_x_val - min_x_val < 1e-6 and max_x_val > 0:
                            tick_values_converted_unit = [min_x_val, max_x_val]
                            if len(set(tick_values_converted_unit)) < 2:
                                tick_values_converted_unit.append(min_x_val + (max_x_val - min_x_val) / 2)
                            tick_values_converted_unit = sorted(list(set(tick_values_converted_unit)))
                        else:
                            num_ticks = 5
                            tick_values_converted_unit = np.linspace(min_x_val, max_x_val, num=num_ticks, endpoint=True)
                        
                        tick_values_seconds = pd.Series(tick_values_converted_unit) * unit_divisor_hist # Convert back to seconds
                        tick_texts_formatted = format_seconds_to_readable(tick_values_seconds, time_format_option).tolist()
                            
                        fig_duration_hist.update_xaxes(
                            type='linear', # Explicitly linear
                            tickvals=tick_values_converted_unit,
                            ticktext=tick_texts_formatted
                        )
                    else: # Fallback for very small non-positive ranges or constant zero
                        fig_duration_hist.update_xaxes(type='linear', tickformat=".1f") # Simple float format
                else: # Default for seconds
                    fig_duration_hist.update_xaxes(type='linear', tickformat=".1f", ticksuffix="s")

                # --- Dynamic Y-axis Log Scale (Count) ---
                if use_log_scale_duration_hist_y:
                    fig_duration_hist.update_yaxes(type='log', title='Count (Log Scale)', rangemode='tozero')
                    st.info("Logarithmic Y-axis applied. Zero counts are handled gracefully.", icon="ℹ️")
                else:
                    fig_duration_hist.update_yaxes(type='linear', title='Count') # Ensure title is reset if going back to linear
                            
                st.plotly_chart(fig_duration_hist, use_container_width=True)
            else: # duration_values_to_plot became empty after general dropna
                st.info("No refresh duration data to display for histogram.", icon="ℹ️")
        # This else-block handles if duration_data_for_hist_df was empty initially (after NO_DATA filter)
        else:
            st.info("No REFRESH_DURATION_SEC data available after excluding 'NO_DATA' refreshes.", icon="ℹ️")
