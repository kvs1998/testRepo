def fetch_dt_tracking_data_cached():
    """
    Fetches data from the T_DYNAMIC_TABLE_TRACKING table.
    """
    session = get_snowflake_session()
    tracking_df = session.sql(f"""
        SELECT
            ID,
            DATABASE_NAME,
            SCHEMA_NAME,
            TABLE_NAME,
            QUALIFIED_NAME,
            TRACK_REFRESH_HISTORY,
            TRACK_METADATA_SNAPSHOT,
            IS_ACTIVE,
            LAST_REFRESH_HISTORY_COLLECTION_STATUS,
            LAST_REFRESH_HISTORY_COLLECTION_MESSAGE,
            LAST_REFRESH_HISTORY_COLLECTION_TIMESTAMP,
            LAST_METADATA_COLLECTION_STATUS,
            LAST_METADATA_COLLECTION_MESSAGE,
            LAST_METADATA_COLLECTION_TIMESTAMP,
            UPDATED_AT -- To get the last time the tracking record was touched/driver ran
        FROM YOUR_DB.YOUR_SCHEMA.T_DYNAMIC_TABLE_TRACKING
        ORDER BY QUALIFIED_NAME ASC
    """).to_pandas()
    
    if not tracking_df.empty:
        for col in ['DATABASE_NAME', 'SCHEMA_NAME', 'TABLE_NAME', 'QUALIFIED_NAME',
                    'LAST_REFRESH_HISTORY_COLLECTION_STATUS', 'LAST_METADATA_COLLECTION_STATUS',
                    'LAST_REFRESH_HISTORY_COLLECTION_MESSAGE', 'LAST_METADATA_COLLECTION_MESSAGE']: # Include messages
            if col in tracking_df.columns:
                tracking_df[col] = tracking_df[col].fillna('N/A').astype(str)
        for col in ['LAST_REFRESH_HISTORY_COLLECTION_TIMESTAMP', 'LAST_METADATA_COLLECTION_TIMESTAMP', 'UPDATED_AT']:
             if col in tracking_df.columns:
                 tracking_df[col] = pd.to_datetime(tracking_df[col], errors='coerce')
    return tracking_df




# tabs/driver_logs_tab.py
import streamlit as st
import pandas as pd
import plotly.express as px

def render_driver_logs_tab(tracking_df: pd.DataFrame):
    st.header("Collection Driver Status & Logs")
    st.write("Monitor the health and execution status of the data collection pipeline.")

    if tracking_df.empty:
        st.info("No tracking data available. Ensure the collection driver is running and populating 'T_DYNAMIC_TABLE_TRACKING'.", icon="ℹ️")
        return

    st.markdown("---")
    st.subheader("Overall Driver Health KPIs")

    total_tables_tracked = tracking_df['QUALIFIED_NAME'].nunique()
    active_tables_tracked = tracking_df[tracking_df['IS_ACTIVE'] == True]['QUALIFIED_NAME'].nunique()

    # Determine last overall driver run time (max UPDATED_AT from any active table)
    last_driver_run_time = tracking_df['UPDATED_AT'].max() if not tracking_df['UPDATED_AT'].empty else "N/A"
    
    # Count tables with recent failures (e.g., in last 24 hours, or just count 'FAILED' statuses)
    # For simplicity, let's count overall failed statuses for now.
    failed_refresh_history_collections = tracking_df[tracking_df['LAST_REFRESH_HISTORY_COLLECTION_STATUS'] == 'FAILED']['QUALIFIED_NAME'].nunique()
    failed_metadata_collections = tracking_df[tracking_df['LAST_METADATA_COLLECTION_STATUS'] == 'FAILED']['QUALIFIED_NAME'].nunique()

    kpi_cols_driver_1 = st.columns(3)
    with kpi_cols_driver_1[0]:
        st.markdown(f"<p style='font-size:14px; margin-bottom:0;'>Total Tables Tracked</p>", unsafe_allow_html=True)
        st.markdown(f"<h3 style='margin-top:0;'>{total_tables_tracked}</h3>", unsafe_allow_html=True)
    with kpi_cols_driver_1[1]:
        st.markdown(f"<p style='font-size:14px; margin-bottom:0;'>Active Tables Monitored</p>", unsafe_allow_html=True)
        st.markdown(f"<h3 style='margin-top:0;'>{active_tables_tracked}</h3>", unsafe_allow_html=True)
    with kpi_cols_driver_1[2]:
        st.markdown(f"<p style='font-size:14px; margin-bottom:0;'>Last Driver Activity</p>", unsafe_allow_html=True)
        st.markdown(f"<h3 style='margin-top:0;'>{last_driver_run_time.strftime('%Y-%m-%d %H:%M:%S') if isinstance(last_driver_run_time, pd.Timestamp) else last_driver_run_time}</h3>", unsafe_allow_html=True)

    kpi_cols_driver_2 = st.columns(2)
    with kpi_cols_driver_2[0]:
        st.markdown(f"<p style='font-size:14px; color:red; margin-bottom:0;'>Tables with Refresh History Failure</p>", unsafe_allow_html=True)
        st.markdown(f"<h3 style='margin-top:0;'>{failed_refresh_history_collections}</h3>", unsafe_allow_html=True)
    with kpi_cols_driver_2[1]:
        st.markdown(f"<p style='font-size:14px; color:red; margin-bottom:0;'>Tables with Metadata Snapshot Failure</p>", unsafe_allow_html=True)
        st.markdown(f"<h3 style='margin-top:0;'>{failed_metadata_collections}</h3>", unsafe_allow_html=True)

    st.divider()

    # --- Collection Status Summary by Collection Type (Bar Chart) ---
    st.subheader("Collection Status Distribution")
    st.write("Breakdown of tables by their last collection status for Refresh History and Metadata Snapshot.")

    # Prepare data for plotting status for each collection type
    status_data = []
    if 'LAST_REFRESH_HISTORY_COLLECTION_STATUS' in tracking_df.columns:
        refresh_history_status_counts = tracking_df['LAST_REFRESH_HISTORY_COLLECTION_STATUS'].value_counts().reset_index()
        refresh_history_status_counts.columns = ['Status', 'Count']
        refresh_history_status_counts['Collection_Type'] = 'Refresh History'
        status_data.append(refresh_history_status_counts)
    
    if 'LAST_METADATA_COLLECTION_STATUS' in tracking_df.columns:
        metadata_status_counts = tracking_df['LAST_METADATA_COLLECTION_STATUS'].value_counts().reset_index()
        metadata_status_counts.columns = ['Status', 'Count']
        metadata_status_counts['Collection_Type'] = 'Metadata Snapshot'
        status_data.append(metadata_status_counts)

    if status_data:
        combined_status_df = pd.concat(status_data)
        
        # Order statuses for consistent plotting
        status_order = ['SUCCESS', 'FAILED', 'UNKNOWN', 'N/A'] # N/A if never ran or default
        combined_status_df['Status'] = pd.Categorical(combined_status_df['Status'], categories=status_order, ordered=True)
        combined_status_df = combined_status_df.sort_values(['Collection_Type', 'Status'])

        fig_collection_status = px.bar(
            combined_status_df,
            x='Count',
            y='Collection_Type',
            color='Status',
            orientation='h',
            barmode='stack', # Stack success and fail
            title='Last Collection Status by Type',
            labels={'Count': 'Number of Tables', 'Collection_Type': 'Collection Type', 'Status': 'Status'},
            color_discrete_map={'SUCCESS': 'green', 'FAILED': 'red', 'N/A': 'grey', 'UNKNOWN': 'lightgray'}
        )
        fig_collection_status.update_yaxes(categoryorder="array", categoryarray=['Refresh History', 'Metadata Snapshot'][::-1]) # Keep consistent order
        st.plotly_chart(fig_collection_status, use_container_width=True)
    else:
        st.info("No collection status data to display.", icon="ℹ️")

    st.divider()

    # --- Collection Status per Table (Detailed Table View) ---
    st.subheader("Detailed Collection Status per Table")
    st.write("View the last collection attempt status and messages for each dynamic table being tracked.")

    # Columns to display in the detailed table
    detailed_cols_to_display = [
        'QUALIFIED_NAME', 
        'IS_ACTIVE',
        'TRACK_REFRESH_HISTORY', 
        'LAST_REFRESH_HISTORY_COLLECTION_TIMESTAMP', 
        'LAST_REFRESH_HISTORY_COLLECTION_STATUS', 
        'LAST_REFRESH_HISTORY_COLLECTION_MESSAGE',
        'TRACK_METADATA_SNAPSHOT',
        'LAST_METADATA_COLLECTION_TIMESTAMP',
        'LAST_METADATA_COLLECTION_STATUS',
        'LAST_METADATA_COLLECTION_MESSAGE',
        'UPDATED_AT' # When the tracking record was last updated (driver run time)
    ]
    
    # Friendly labels for the detailed table
    detailed_labels_map = {
        'QUALIFIED_NAME': 'Dynamic Table',
        'IS_ACTIVE': 'Active?',
        'TRACK_REFRESH_HISTORY': 'Track Refresh History?',
        'LAST_REFRESH_HISTORY_COLLECTION_TIMESTAMP': 'Last RH Collect Time',
        'LAST_REFRESH_HISTORY_COLLECTION_STATUS': 'Last RH Status',
        'LAST_REFRESH_HISTORY_COLLECTION_MESSAGE': 'Last RH Message',
        'TRACK_METADATA_SNAPSHOT': 'Track Metadata Snapshot?',
        'LAST_METADATA_COLLECTION_TIMESTAMP': 'Last Metadata Collect Time',
        'LAST_METADATA_COLLECTION_STATUS': 'Last Metadata Status',
        'LAST_METADATA_COLLECTION_MESSAGE': 'Last Metadata Message',
        'UPDATED_AT': 'Tracking Record Last Updated'
    }

    # Filters for the detailed table
    filter_detailed_table_cols = st.columns([1, 1])
    with filter_detailed_table_cols[0]:
        status_filter_options = ['All', 'SUCCESS', 'FAILED', 'N/A', 'UNKNOWN']
        selected_rh_status = st.selectbox(
            "Filter by Refresh History Status:", options=status_filter_options, key="filter_rh_status"
        )
    with filter_detailed_table_cols[1]:
        selected_meta_status = st.selectbox(
            "Filter by Metadata Snapshot Status:", options=status_filter_options, key="filter_meta_status"
        )
    
    detailed_filtered_df = tracking_df.copy()

    if selected_rh_status != 'All':
        detailed_filtered_df = detailed_filtered_df[detailed_filtered_df['LAST_REFRESH_HISTORY_COLLECTION_STATUS'] == selected_rh_status].copy()
    if selected_meta_status != 'All':
        detailed_filtered_df = detailed_filtered_df[detailed_filtered_df['LAST_METADATA_COLLECTION_STATUS'] == selected_meta_status].copy()

    if not detailed_filtered_df.empty:
        # Sort for display: failed first, then by last updated time
        detailed_filtered_df = detailed_filtered_df.sort_values(
            ['LAST_REFRESH_HISTORY_COLLECTION_STATUS', 'LAST_METADATA_COLLECTION_STATUS', 'UPDATED_AT'],
            ascending=[True, True, False]
        )
        st.dataframe(
            detailed_filtered_df[[col for col in detailed_cols_to_display if col in detailed_filtered_df.columns]].rename(columns=detailed_labels_map),
            use_container_width=True
        )
    else:
        st.info("No detailed collection status data to display based on current filters.", icon="ℹ️")
