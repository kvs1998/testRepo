# Chart 3: Refresh Duration Trend & Refresh Duration vs. Rows Processed (Side-by-side)
    chart_cols_pair2 = st.columns([1, 1]) # Main two columns

    with chart_cols_pair2[0]: # LEFT COLUMN: Refresh Duration Trend
        cols_chart_header = st.columns(
            [0.8, 0.2]
        )  # Internal columns for title and checkbox
        with cols_chart_header[0]:
            st.markdown(
                "<p style='font-size:16px;'><b>Refresh Duration Trend</b></p>",
                unsafe_allow_html=True,
            )
        with cols_chart_header[1]:
            use_log_scale_duration_trend = st.checkbox(
                "Log Scale Y-axis", key="log_scale_duration_trend_dt_state"
            )
        st.write("Average, Median, and P95 refresh duration over time.")

        if (
            "REFRESH_DURATION_SEC" in filtered_history_df.columns
            and not filtered_history_df["REFRESH_DURATION_SEC"].empty
        ):
            duration_trend_df = (
                filtered_history_df.groupby(
                    pd.Grouper(key="DATA_TIMESTAMP_DT", freq="D")
                )["REFRESH_DURATION_SEC"]
                .agg(["mean", "median", lambda x: x.quantile(0.95)])
                .reset_index()
            )
            duration_trend_df.columns = [
                "Date",
                "Mean Duration",
                "Median Duration",
                "P95 Duration",
            ]

            fig_duration_trend = px.line(
                duration_trend_df,
                x="Date",
                y=["Mean Duration", "Median Duration", "P95 Duration"],
                labels={"value": f"Duration ({time_format_option})"},
            )
            fig_duration_trend.update_layout(
                title_text="",
                legend=dict(
                    orientation="h",
                    yanchor="bottom",
                    y=1.02,
                    xanchor="right",
                    x=1
                )
            )

            if use_log_scale_duration_trend:
                if duration_trend_df[['Mean Duration', 'Median Duration', 'P95 Duration']].sum().sum() > 0:
                    fig_duration_trend.update_yaxes(
                        type="log", title="Duration (Log Scale)", rangemode="tozero"
                    )
                    st.info(
                        "Logarithmic scale applied to Y-axis. Zero/negative values are handled gracefully.",
                        icon="ℹ️",
                    )
                else:
                    st.warning("Cannot apply log scale: All duration metrics are zero for the selected period.", icon="⚠️")

            st.plotly_chart(fig_duration_trend, use_container_width=True)
        else:
            st.info(
                "No REFRESH_DURATION_SEC data available for trend analysis.",
                icon="ℹ️",
            )

    with chart_cols_pair2[1]: # RIGHT COLUMN: Refresh Duration vs. Rows Processed
        # Headers and initial write
        st.markdown(
            "<p style='font-size:16px;'><b>Refresh Duration vs. Rows Processed</b></p>",
            unsafe_allow_html=True,
        )
        st.write("Examine if duration correlates with data volume. Helps identify inefficiencies.")

        all_row_metrics_scatter = {
            "Total Rows Changed": [
                "NUMINSERTEDROWS",
                "NUMDELETEDROWS",
                "NUMCOPIEDROWS",
                "NUMADDEDPARTITIONS",
                "NUMREMOVEDPARTITIONS",
            ],
            "Inserted Rows": ["NUMINSERTEDROWS"],
            "Deleted Rows": ["NUMDELETEDROWS"],
            "Copied Rows": ["NUMCOPIEDROWS"],
            "Added Partitions": ["NUMADDEDPARTITIONS"],
            "Removed Partitions": ["NUMREMOVEDPARTITIONS"],
        }

        available_row_metrics_scatter = {
            label: cols
            for label, cols in all_row_metrics_scatter.items()
            if all(c in filtered_history_df.columns for c in cols)
        }

        if (
            "REFRESH_DURATION_SEC" in filtered_history_df.columns
            and available_row_metrics_scatter
        ):
            # --- START: ALIGNMENT FIX (Nested Columns) ---
            # Create a row for the selectbox and log scale checkboxes
            scatter_controls_col1, scatter_controls_col2, scatter_controls_col3 = st.columns([2, 1, 1])

            with scatter_controls_col1:
                selected_row_metric_for_scatter = st.selectbox(
                    "X-axis Metric:", # Shorter label for better fit
                    options=list(available_row_metrics_scatter.keys()),
                    key="scatter_x_axis_metric"
                )
            
            with scatter_controls_col2:
                log_x_scatter = st.checkbox("Log X-axis", key="log_x_scatter_dt_state")
            
            with scatter_controls_col3:
                log_y_scatter = st.checkbox("Log Y-axis", key="log_y_scatter_dt_state")
            # --- END: ALIGNMENT FIX ---


            cols_to_sum = available_row_metrics_scatter[
                selected_row_metric_for_scatter
            ]
            scatter_df = filtered_history_df.copy()
            scatter_df["X_AXIS_METRIC_VALUE"] = scatter_df[cols_to_sum].sum(
                axis=1
            )

            scatter_df = scatter_df.dropna(
                subset=["REFRESH_DURATION_SEC", "X_AXIS_METRIC_VALUE"]
            ).copy()

            for col in [
                "STATE_MESSAGE",
                "REFRESH_ACTION",
                "QUALIFIED_NAME",
                "STATE",
            ]:
                if col in scatter_df.columns:
                    scatter_df[col] = scatter_df[col].fillna("N/A")

            # Remove the old log_scales_cols and the checkboxes within them,
            # as they are now defined above.

            if log_x_scatter or log_y_scatter:
                scatter_df = scatter_df[
                    (scatter_df["REFRESH_DURATION_SEC"] > 0)
                    & (scatter_df["X_AXIS_METRIC_VALUE"] > 0)
                ].copy()

            if not scatter_df.empty:
                scatter_df["REFRESH_START_TIME_FMT"] = (
                    scatter_df["REFRESH_START_TIME_DT"]
                    .dt.strftime("%Y-%m-%d %H:%M:%S")
                    .fillna("N/A")
                )
                scatter_df["REFRESH_END_TIME_FMT"] = (
                    scatter_df["REFRESH_END_TIME_DT"]
                    .dt.strftime("%Y-%m-%d %H:%M:%S")
                    .fillna("N/A")
                )
                scatter_df[
                    "REFRESH_DURATION_FMT_HOVER"
                ] = format_seconds_to_readable(
                    scatter_df["REFRESH_DURATION_SEC"], time_format_option
                )
                scatter_df["X_AXIS_METRIC_FMT_HOVER"] = scatter_df[
                    "X_AXIS_METRIC_VALUE"
                ].apply(lambda x: f"{int(x):,}")

                fig_duration_vs_rows = px.scatter(
                    scatter_df,
                    x="X_AXIS_METRIC_VALUE",
                    y="REFRESH_DURATION_SEC",
                    color="STATE",
                    labels={
                        "REFRESH_DURATION_SEC": f"Duration ({time_format_option})",
                        "X_AXIS_METRIC_VALUE": selected_row_metric_for_scatter,
                    },
                    color_discrete_map={
                        "SUCCEEDED": "blue",
                        "FAILED": "red",
                        "UPSTREAM_FAILED": "darkred",
                        "CANCELLED": "orange",
                        "EXECUTING": "green",
                        "SCHEDULED": "grey",
                        "UNKNOWN": "purple",
                    },
                )

                fig_duration_vs_rows.update_traces(
                    hovertemplate=(
                        "<b>Table: %{customdata[0]}</b><br>"
                        "State: %{customdata[1]}<br>"
                        f"{selected_row_metric_for_scatter}: %{{customdata[2]}}<br>"
                        "Duration: %{customdata[3]}<br>"
                        "Action: %{customdata[4]}<br>"
                        "Start: %{customdata[5]}<br>"
                        "End: %{customdata[6]}<br>"
                        "Message: %{customdata[7]}<br>"
                        "<extra></extra>"
                    ),
                    customdata=np.stack(
                        (
                            scatter_df["QUALIFIED_NAME"],
                            scatter_df["STATE"],
                            scatter_df["X_AXIS_METRIC_FMT_HOVER"],
                            scatter_df["REFRESH_DURATION_FMT_HOVER"],
                            scatter_df["REFRESH_ACTION"],
                            scatter_df["REFRESH_START_TIME_FMT"],
                            scatter_df["REFRESH_END_TIME_FMT"],
                            scatter_df["STATE_MESSAGE"],
                        ),
                        axis=-1,
                    ),
                )
                fig_duration_vs_rows.update_layout(
                    legend=dict(
                        orientation="h",
                        yanchor="bottom",
                        y=1.02,
                        xanchor="right",
                        x=1
                    )
                )

                if log_x_scatter:
                    fig_duration_vs_rows.update_xaxes(type="log")
                if log_y_scatter:
                    fig_duration_vs_rows.update_yaxes(type="log")

                st.plotly_chart(
                    fig_duration_vs_rows, use_container_width=True
                )
            else:
                st.info(
                    f"No valid data for Refresh Duration vs. {selected_row_metric_for_scatter} scatter plot after filters (considering log scale requirements).",
                    icon="ℹ️",
                )
        else:
            st.info(
                "Necessary columns for Refresh Duration vs. Rows Processed analysis not available or no data after filters.",
                icon="ℹ️",
            )
