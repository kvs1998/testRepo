with chart_cols_pair2[1]: # Refresh Duration vs. Rows Processed (Scatter Plot)
        st.markdown("<p style='font-size:16px;'><b>Refresh Duration vs. Rows Processed</b></p>", unsafe_allow_html=True)
        st.write("Examine if duration correlates with data volume.")
        
        all_row_metrics_scatter = {
            'Total Rows Changed': ['NUMINSERTEDROWS', 'NUMDELETEDROWS', 'NUMCOPIEDROWS', 'NUMADDEDPARTITIONS', 'NUMREMOVEDPARTITIONS'],
            'Inserted Rows': ['NUMINSERTEDROWS'],
            'Deleted Rows': ['NUMDELETEDROWS'],
            'Copied Rows': ['NUMCOPIEDROWS'],
            'Added Partitions': ['NUMADDEDPARTITIONS'],
            'Removed Partitions': ['NUMREMOVEDPARTITIONS']
        }
        
        available_row_metrics_scatter = {
            label: cols for label, cols in all_row_metrics_scatter.items()
            if all(c in filtered_history_df.columns for c in cols)
        }

        if 'REFRESH_DURATION_SEC' in filtered_history_df.columns and available_row_metrics_scatter:
            selected_row_metric_for_scatter = st.selectbox(
                "Select X-axis Row Metric:",
                options=list(available_row_metrics_scatter.keys()),
                key="scatter_x_axis_metric"
            )

            cols_to_sum = available_row_metrics_scatter[selected_row_metric_for_scatter]
            
            # --- START SCATTER PLOT FIXES ---
            # Create scatter_df, explicitly handling copies
            scatter_df = filtered_history_df.copy() # Make initial copy

            # Calculate X-axis metric value
            scatter_df['X_AXIS_METRIC_VALUE'] = scatter_df[cols_to_sum].sum(axis=1)

            # --- TRANSFORM Y-AXIS DATA TO SELECTED DISPLAY UNIT FOR PLOTTING ---
            # This makes plotting units consistent with selected time_format_option
            if time_format_option == 'minutes':
                scatter_df['Y_AXIS_PLOT_VALUE'] = scatter_df['REFRESH_DURATION_SEC'] / 60
            elif time_format_option == 'hours':
                scatter_df['Y_AXIS_PLOT_VALUE'] = scatter_df['REFRESH_DURATION_SEC'] / 3600
            elif time_format_option == 'days':
                scatter_df['Y_AXIS_PLOT_VALUE'] = scatter_df['REFRESH_DURATION_SEC'] / 86400
            else: # Default to seconds or mixed (mixed will plot seconds)
                scatter_df['Y_AXIS_PLOT_VALUE'] = scatter_df['REFRESH_DURATION_SEC']
            
            # Filter out 'NO_DATA' actions (often have 0 duration, 0 rows) as they are not relevant for performance correlation
            scatter_df = scatter_df[scatter_df['REFRESH_ACTION'] != 'NO_DATA'].copy()
            
            # Drop NaNs critical for plotting (duration, x_value, hover info)
            # Ensure essential hover columns are non-null string types.
            scatter_df['QUALIFIED_NAME'] = scatter_df['QUALIFIED_NAME'].fillna('N/A').astype(str)
            scatter_df['STATE'] = scatter_df['STATE'].fillna('N/A').astype(str)
            scatter_df['REFRESH_ACTION'] = scatter_df['REFRESH_ACTION'].fillna('N/A').astype(str)
            scatter_df['STATE_MESSAGE'] = scatter_df['STATE_MESSAGE'].fillna('N/A').astype(str)

            scatter_df = scatter_df.dropna(subset=['Y_AXIS_PLOT_VALUE', 'X_AXIS_METRIC_VALUE']).copy()

            # --- LOG SCALE CHECKBOXES & ZERO/NEGATIVE VALUE HANDLING ---
            # These are defined here, then their values are used for filtering right below.
            log_scales_cols = st.columns([1, 1])
            with log_scales_cols[0]:
                log_x_scatter = st.checkbox("Log X-axis", key="log_x_scatter_dt_state")
            with log_scales_cols[1]:
                log_y_scatter = st.checkbox("Log Y-axis", key="log_y_scatter_dt_state")

            if log_x_scatter or log_y_scatter:
                initial_count_before_log_filter = len(scatter_df)
                scatter_df = scatter_df[
                    (scatter_df['Y_AXIS_PLOT_VALUE'] > 0) & # Filter on the converted Y-axis value
                    (scatter_df['X_AXIS_METRIC_VALUE'] > 0)
                ].copy()
                if len(scatter_df) < initial_count_before_log_filter:
                    st.info(f"Note: {initial_count_before_log_filter - len(scatter_df)} data point(s) with zero/negative values were excluded for log scale display.", icon="ℹ️")


            if not scatter_df.empty:
                # --- PREPARE HOVER DATA ---
                # Format timestamps and duration for hover text
                scatter_df['REFRESH_START_TIME_FMT'] = scatter_df['REFRESH_START_TIME_DT'].dt.strftime('%Y-%m-%d %H:%M:%S').fillna("N/A")
                scatter_df['REFRESH_END_TIME_FMT'] = scatter_df['REFRESH_END_TIME_DT'].dt.strftime('%Y-%m-%d %H:%M:%S').fillna("N/A")
                
                # REFRESH_DURATION_FMT_HOVER will still use the original SECONDS for consistent format_seconds_to_readable output
                scatter_df['REFRESH_DURATION_FMT_HOVER'] = format_seconds_to_readable(scatter_df['REFRESH_DURATION_SEC'], time_format_option)
                scatter_df['X_AXIS_METRIC_FMT_HOVER'] = scatter_df['X_AXIS_METRIC_VALUE'].apply(lambda x: f"{int(x):,}")


                fig_duration_vs_rows = px.scatter(
                    scatter_df,
                    x='X_AXIS_METRIC_VALUE', # Plotting X in raw value
                    y='Y_AXIS_PLOT_VALUE',   # PLOTTING THE CONVERTED Y-AXIS VALUE (e.g., in minutes, hours)
                    color='STATE', # Color by refresh state
                    # Explicitly control hover data via customdata
                    hover_data={
                        'QUALIFIED_NAME': False, 'STATE': False, 'REFRESH_ACTION': False,
                        'STATE_MESSAGE': False, 'REFRESH_START_TIME_DT': False, 'REFRESH_END_TIME_DT': False
                    },
                    # --- AXIS LABELS ---
                    labels={
                        'Y_AXIS_PLOT_VALUE': f'Duration ({time_format_option})', # Dynamic Y-axis label
                        'X_AXIS_METRIC_VALUE': selected_row_metric_for_scatter
                    },
                    color_discrete_map={ # Explicitly map ALL possible colors for consistency and visibility
                        'SUCCEEDED': 'blue',
                        'FAILED': 'red',
                        'UPSTREAM_FAILED': 'darkred',
                        'CANCELLED': 'orange',
                        'EXECUTING': 'green',
                        'SCHEDULED': 'grey',
                        'UNKNOWN': 'purple' # Include unknown if it can appear in data
                    }
                )
                fig_duration_vs_rows.update_layout(title_text='') # Remove title_text


                # --- UPDATE AXES FOR FORMATTING/LOG SCALE ---
                # X-axis (Row Changes)
                if log_x_scatter:
                    fig_duration_vs_rows.update_xaxes(type='log', rangemode='tozero', automargin=True)
                else:
                    fig_duration_vs_rows.update_xaxes(type='linear', tickformat=',.0s', automargin=True) # E.g., 100, 1k, 1M, 1G
                
                # Y-axis (Duration)
                if log_y_scatter:
                    fig_duration_vs_rows.update_yaxes(type='log', rangemode='tozero', automargin=True)
                else: # Linear scale for Y, apply dynamic tick text
                    # For Y-axis, Plotly's tickformat does not handle 'mixed' or '1m' well.
                    # We need to explicitly calculate tick values in the PLOTTING unit (Y_AXIS_PLOT_VALUE)
                    # and format their text for display.
                    
                    # Get the current min/max of the Y-axis (in converted units from Y_AXIS_PLOT_VALUE)
                    min_y_val = scatter_df['Y_AXIS_PLOT_VALUE'].min()
                    max_y_val = scatter_df['Y_AXIS_PLOT_VALUE'].max()
                    
                    if max_y_val > min_y_val and max_y_val > 0:
                        num_ticks = 5 # Default number of ticks
                        tick_values_converted_unit = np.linspace(min_y_val, max_y_val, num=num_ticks, endpoint=True)
                        
                        # Convert these tick values BACK to seconds for format_seconds_to_readable
                        # format_seconds_to_readable takes seconds_series as input
                        if time_format_option == 'minutes':
                            tick_values_seconds = tick_values_converted_unit * 60
                        elif time_format_option == 'hours':
                            tick_values_seconds = tick_values_converted_unit * 3600
                        elif time_format_option == 'days':
                            tick_values_seconds = tick_values_converted_unit * 86400
                        else: # 'seconds' or 'mixed' (where plotting is already in seconds)
                            tick_values_seconds = tick_values_converted_unit

                        tick_texts_formatted = format_seconds_to_readable(pd.Series(tick_values_seconds), time_format_option).tolist()
                        
                        fig_duration_vs_rows.update_yaxes(
                            type='linear', # Ensure linear type
                            tickvals=tick_values_converted_unit,
                            ticktext=tick_texts_formatted,
                            automargin=True
                        )
                    else: # Fallback for edge cases with zero/min data or no range
                        fig_duration_vs_rows.update_yaxes(type='linear', tickformat=".1f", automargin=True) # Simple float format

                # --- Custom hovertemplate for scatter plot ---
                fig_duration_vs_rows.update_traces(
                    hovertemplate=(
                        '<b>Table: %{customdata[0]}</b><br>' # QUALIFIED_NAME from customdata
                        'State: %{customdata[1]}<br>'       # STATE from customdata
                        f'{selected_row_metric_for_scatter}: %{{customdata[2]}}<br>' # Formatted row change value
                        'Duration: %{customdata[3]}<br>' # Formatted duration hover value
                        'Action: %{customdata[4]}<br>'
                        'Start: %{customdata[5]}<br>'
                        'End: %{customdata[6]}<br>'
                        'Message: %{customdata[7]}<br>'
                        '<extra></extra>'
                    ),
                    customdata=np.stack((
                        scatter_df['QUALIFIED_NAME'],
                        scatter_df['STATE'], # Use raw state string for hover
                        scatter_df['X_AXIS_METRIC_FMT_HOVER'],
                        scatter_df['REFRESH_DURATION_FMT_HOVER'],
                        scatter_df['REFRESH_ACTION'],
                        scatter_df['REFRESH_START_TIME_FMT'],
                        scatter_df['REFRESH_END_TIME_FMT'],
                        scatter_df['STATE_MESSAGE']
                    ), axis=-1)
                )
                
                st.plotly_chart(fig_duration_vs_rows, use_container_width=True)
            else: # If scatter_df became empty after log scale filtering
                st.info(f"No valid data points for Refresh Duration vs. {selected_row_metric_for_scatter} scatter plot after filters (considering zero/negative values for log scales). Please adjust filters.", icon="ℹ️")
        else: # If essential columns are missing from filtered_history_df
            st.info("Necessary columns for Refresh Duration vs. Rows Processed analysis not available or no data after filters.", icon="ℹ️")
    
    st.divider()
