with chart_cols_pair2[0]: # Refresh Duration Trend
        st.markdown("<p style='font-size:16px;'><b>Refresh Duration Trend</b></p>", unsafe_allow_html=True)
        if not filtered_history_df.empty:
            duration_trend_df = filtered_history_df.groupby(
                pd.Grouper(key='DATA_TIMESTAMP_DT', freq='D')
            )['REFRESH_DURATION_SEC'].agg(['mean', 'median', lambda x: x.quantile(0.95)]).reset_index()
            duration_trend_df.columns = ['Date', 'Mean Duration', 'Median Duration', 'P95 Duration']

            # --- TRANSFORM Y-AXIS DATA TO SELECTED DISPLAY UNIT FOR PLOTTING ---
            # Create columns for plotting in the selected time format
            if time_format_option == 'minutes':
                duration_trend_df['Mean_Duration_Plot'] = duration_trend_df['Mean Duration'] / 60
                duration_trend_df['Median_Duration_Plot'] = duration_trend_df['Median Duration'] / 60
                duration_trend_df['P95_Duration_Plot'] = duration_trend_df['P95 Duration'] / 60
            elif time_format_option == 'hours':
                duration_trend_df['Mean_Duration_Plot'] = duration_trend_df['Mean Duration'] / 3600
                duration_trend_df['Median_Duration_Plot'] = duration_trend_df['Median Duration'] / 3600
                duration_trend_df['P95_Duration_Plot'] = duration_trend_df['P95 Duration'] / 3600
            elif time_format_option == 'days':
                duration_trend_df['Mean_Duration_Plot'] = duration_trend_df['Mean Duration'] / 86400
                duration_trend_df['Median_Duration_Plot'] = duration_trend_df['Median Duration'] / 86400
                duration_trend_df['P95_Duration_Plot'] = duration_trend_df['P95 Duration'] / 86400
            else: # 'seconds' or 'mixed' (plot in seconds)
                duration_trend_df['Mean_Duration_Plot'] = duration_trend_df['Mean Duration']
                duration_trend_df['Median_Duration_Plot'] = duration_trend_df['Median Duration']
                duration_trend_df['P95_Duration_Plot'] = duration_trend_df['P95 Duration']
            
            # --- Prepare hover text for line chart ---
            duration_trend_df['Mean_Duration_FMT_Hover'] = format_seconds_to_readable(duration_trend_df['Mean Duration'], time_format_option)
            duration_trend_df['Median_Duration_FMT_Hover'] = format_seconds_to_readable(duration_trend_df['Median Duration'], time_format_option)
            duration_trend_df['P95_Duration_FMT_Hover'] = format_seconds_to_readable(duration_trend_df['P95 Duration'], time_format_option)


            fig_duration_trend = px.line(
                duration_trend_df,
                x='Date',
                y=['Mean_Duration_Plot', 'Median_Duration_Plot', 'P95_Duration_Plot'], # Plot converted values
                title='Daily Refresh Duration Trend (Mean, Median, P95)', # Redundant title
                labels={'value': f'Duration ({time_format_option})'} # Dynamic Y-axis label
            )
            fig_duration_trend.update_layout(title_text='')

            if use_log_scale_duration_trend:
                fig_duration_trend.update_yaxes(type='log', title='Duration (Log Scale)', rangemode='tozero')
                st.info("Logarithmic scale applied to Y-axis.", icon="ℹ️")

            # --- Custom Hovertemplate for line chart ---
            # Update traces to use customdata for formatted values
            # The 'name' of the trace corresponds to the column name in 'y' argument (e.g. 'Mean_Duration_Plot')
            for trace in fig_duration_trend.data:
                if trace.name == 'Mean_Duration_Plot':
                    trace.hovertemplate = '<b>Date:</b> %{x|%Y-%m-%d}<br><b>Mean Duration:</b> %{customdata}<extra></extra>'
                    trace.customdata = duration_trend_df['Mean_Duration_FMT_Hover']
                elif trace.name == 'Median_Duration_Plot':
                    trace.hovertemplate = '<b>Date:</b> %{x|%Y-%m-%d}<br><b>Median Duration:</b> %{customdata}<extra></extra>'
                    trace.customdata = duration_trend_df['Median_Duration_FMT_Hover']
                elif trace.name == 'P95_Duration_Plot':
                    trace.hovertemplate = '<b>Date:</b> %{x|%Y-%m-%d}<br><b>P95 Duration:</b> %{customdata}<extra></extra>'
                    trace.customdata = duration_trend_df['P95_Duration_FMT_Hover']


            # --- Dynamic Tick Formatting for Y-axis (Duration Trend) ---
            if time_format_option != 'seconds' and not use_log_scale_duration_trend:
                min_y_val = fig_duration_trend.layout.yaxis.range[0] if fig_duration_trend.layout.yaxis.range else duration_trend_df['Y_AXIS_PLOT_VALUE'].min() # This Y_AXIS_PLOT_VALUE needs to be available
                max_y_val = fig_duration_trend.layout.yaxis.range[1] if fig_duration_trend.layout.yaxis.range else duration_trend_df['Y_AXIS_PLOT_VALUE'].max()
                
                # Here, the range for tick generation should use the max of the PLOT values across all three lines
                max_plot_value = duration_trend_df[['Mean_Duration_Plot', 'Median_Duration_Plot', 'P95_Duration_Plot']].max().max()
                min_plot_value = duration_trend_df[['Mean_Duration_Plot', 'Median_Duration_Plot', 'P95_Duration_Plot']].min().min()

                if max_plot_value > min_plot_value and max_plot_value > 0:
                    num_ticks = 5
                    tick_values_converted_unit = np.linspace(min_plot_value, max_plot_value, num=num_ticks, endpoint=True)
                    
                    if time_format_option == 'minutes':
                        tick_values_seconds = tick_values_converted_unit * 60
                    elif time_format_option == 'hours':
                        tick_values_seconds = tick_values_converted_unit * 3600
                    elif time_format_option == 'days':
                        tick_values_seconds = tick_values_converted_unit * 86400
                    else: # 'seconds' or 'mixed'
                        tick_values_seconds = tick_values_converted_unit
                        
                    tick_texts_formatted = format_seconds_to_readable(pd.Series(tick_values_seconds), time_format_option).tolist()
                    
                    fig_duration_trend.update_yaxes(
                        type='linear',
                        tickvals=tick_values_converted_unit,
                        ticktext=tick_texts_formatted
                    )
                else:
                    fig_duration_trend.update_yaxes(type='linear', tickformat=".1f") # Fallback

            st.plotly_chart(fig_duration_trend, use_container_width=True)
        else:
            st.info("No REFRESH_DURATION_SEC data available for trend analysis.", icon="ℹ️")
