with chart_cols_pair3[0]: # Refresh Duration Distribution (Histogram) - CORRECTED PLACEMENT
        cols_chart_header = st.columns([0.8, 0.2]) # Internal columns for title and checkbox
        with cols_chart_header[0]:
            st.markdown("<p style='font-size:16px;'><b>Refresh Duration Distribution</b></p>", unsafe_allow_html=True)
        with cols_chart_header[1]:
            use_log_scale_duration_hist = st.checkbox("Log Scale X-axis", key="log_scale_duration_hist_dt_state")
        st.write("Distribution of refresh durations.")
        
        if 'REFRESH_DURATION_SEC' in filtered_history_df.columns and not filtered_history_df['REFRESH_DURATION_SEC'].empty:
            duration_data = filtered_history_df['REFRESH_DURATION_SEC'].dropna().copy()
            
            if use_log_scale_duration_hist:
                 duration_data = duration_data.apply(lambda x: x if x > 0 else 1e-9)


            if not duration_data.empty:
                fig_duration_hist = px.histogram(
                    duration_data,
                    x="REFRESH_DURATION_SEC",
                    nbins=20,
                    labels={'REFRESH_DURATION_SEC': f'Duration ({time_format_option})'}, # Dynamic label based on format
                    text_auto=False
                )
                fig_duration_hist.update_layout(bargap=0.1, title_text='')

                if use_log_scale_duration_hist:
                    fig_duration_hist.update_xaxes(type='log', rangemode='tozero')
                    st.info("Logarithmic scale applied to X-axis. Zero counts are handled gracefully.", icon="ℹ️")
                
                if time_format_option != 'seconds':
                    min_x_val = fig_duration_hist.layout.xaxis.range[0] if fig_duration_hist.layout.xaxis.range else duration_data.min()
                    max_x_val = fig_duration_hist.layout.xaxis.range[1] if fig_duration_hist.layout.xaxis.range else duration_data.max()
                    
                    if min_x_val < 1e-9 and use_log_scale_duration_hist:
                        min_x_val = 1.0
                    
                    if max_x_val > 0:
                        if not use_log_scale_duration_hist:
                            tick_values = np.linspace(min_x_val, max_x_val, num=5, endpoint=True)
                        else:
                            log_min = np.floor(np.log10(min_x_val)) if min_x_val > 0 else 0
                            log_max = np.ceil(np.log10(max_x_val))
                            tick_values = np.logspace(log_min, log_max, int(log_max - log_min) + 1)
                            tick_values = tick_values[(tick_values >= min_x_val) & (tick_values <= max_x_val)]
                            if not tick_values.size:
                                tick_values = np.linspace(min_x_val, max_x_val, 3)
                            
                        tick_texts = format_seconds_to_readable(pd.Series(tick_values), time_format_option).tolist()
                        fig_duration_hist.update_xaxes(tickvals=tick_values, ticktext=tick_texts)
                            
                st.plotly_chart(fig_duration_hist, use_container_width=True)
            else:
                st.info("No refresh duration data to display for histogram.", icon="ℹ️")
        else:
            st.info("No REFRESH_DURATION_SEC data available.", icon="ℹ️")
