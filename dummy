with chart_cols_pair2[1]: # Refresh Duration vs. Rows Processed (Scatter Plot)
        st.markdown("<p style='font-size:16px;'><b>Refresh Duration vs. Rows Processed</b></p>", unsafe_allow_html=True)
        st.write("Examine if duration correlates with data volume.")
        
        all_row_metrics_scatter = {
            'Total Rows Changed': ['NUMINSERTEDROWS', 'NUMDELETEDROWS', 'NUMCOPIEDROWS', 'NUMADDEDPARTITIONS', 'NUMREMOVEDPARTITIONS'],
            'Inserted Rows': ['NUMINSERTEDROWS'],
            'Deleted Rows': ['NUMDELETEDROWS'],
            'Copied Rows': ['NUMCOPIEDROWS'],
            'Added Partitions': ['NUMADDEDPARTITIONS'],
            'Removed Partitions': ['NUMREMOVEDPARTITIONS']
        }
        
        available_row_metrics_scatter = {
            label: cols for label, cols in all_row_metrics_scatter.items()
            if all(c in filtered_history_df.columns for c in cols)
        }

        if 'REFRESH_DURATION_SEC' in filtered_history_df.columns and available_row_metrics_scatter:
            # Selectbox for X-axis metric
            selected_row_metric_for_scatter = st.selectbox(
                "Select X-axis Row Metric:",
                options=list(available_row_metrics_scatter.keys()),
                key="scatter_x_axis_metric"
            )

            # Define cols_to_sum AFTER selected_row_metric_for_scatter is selected
            cols_to_sum = available_row_metrics_scatter[selected_row_metric_for_scatter]
            
            # Prepare scatter_df. Perform sum before dropping NaNs relevant to scatter plot.
            scatter_df = filtered_history_df.copy()
            scatter_df['X_AXIS_METRIC_VALUE'] = scatter_df[cols_to_sum].sum(axis=1)

            # Drop NaNs that are critical for plotting (duration, x_value, hover info)
            scatter_df = scatter_df.dropna(subset=['REFRESH_DURATION_SEC', 'X_AXIS_METRIC_VALUE', 'QUALIFIED_NAME', 'STATE', 'REFRESH_ACTION', 'REFRESH_START_TIME_DT', 'REFRESH_END_TIME_DT', 'STATE_MESSAGE']).copy()
            
            # Log scale checkboxes (retrieving values AFTER they've been defined by st.checkbox)
            # Define them immediately before they're used for filtering
            log_scales_cols = st.columns([1, 1])
            with log_scales_cols[0]:
                log_x_scatter = st.checkbox("Log Scale X-axis", key="log_x_scatter_dt_state")
            with log_scales_cols[1]:
                log_y_scatter = st.checkbox("Log Scale Y-axis", key="log_y_scatter_dt_state")


            # Filter out non-positive values if log scale is enabled
            if log_x_scatter or log_y_scatter:
                initial_count = len(scatter_df)
                scatter_df = scatter_df[
                    (scatter_df['REFRESH_DURATION_SEC'] > 0) &
                    (scatter_df['X_AXIS_METRIC_VALUE'] > 0)
                ].copy()
                if len(scatter_df) < initial_count:
                    st.info(f"Note: {initial_count - len(scatter_df)} data point(s) with zero/negative values were excluded for log scale display.", icon="ℹ️")


            if not scatter_df.empty:
                # Format timestamps and duration for hover text
                scatter_df['REFRESH_START_TIME_FMT'] = scatter_df['REFRESH_START_TIME_DT'].dt.strftime('%Y-%m-%d %H:%M:%S').fillna("N/A")
                scatter_df['REFRESH_END_TIME_FMT'] = scatter_df['REFRESH_END_TIME_DT'].dt.strftime('%Y-%m-%d %H:%M:%S').fillna("N/A")
                
                # --- FIX FOR HOVER VALUE DISCREPANCY ---
                # Convert Y-axis (Duration) values to the selected time format for plotting
                # These are the actual values that px.scatter will use for y-coordinate
                scatter_df['Y_AXIS_PLOT_VALUE'] = scatter_df['REFRESH_DURATION_SEC'].apply(
                    lambda x: x / 60 if time_format_option == 'minutes' else
                              x / 3600 if time_format_option == 'hours' else
                              x / 86400 if time_format_option == 'days' else
                              x
                )
                
                # Format hover values - these are just for display in tooltip
                scatter_df['REFRESH_DURATION_FMT_HOVER'] = format_seconds_to_readable(scatter_df['REFRESH_DURATION_SEC'], time_format_option)
                scatter_df['X_AXIS_METRIC_FMT_HOVER'] = scatter_df['X_AXIS_METRIC_VALUE'].apply(lambda x: f"{int(x):,}")

                fig_duration_vs_rows = px.scatter(
                    scatter_df,
                    x='X_AXIS_METRIC_VALUE', # Plotting X in raw value (commas added via tickformat/hover)
                    y='Y_AXIS_PLOT_VALUE', # Plotting Y in selected units
                    color='STATE',
                    labels={
                        'Y_AXIS_PLOT_VALUE': f'Duration ({time_format_option})', # Dynamic Y-axis label
                        'X_AXIS_METRIC_VALUE': selected_row_metric_for_scatter
                    },
                    color_discrete_map={
                        'SUCCEEDED': 'blue', 'FAILED': 'red', 'UPSTREAM_FAILED': 'darkred',
                        'CANCELLED': 'orange', 'EXECUTING': 'green', 'SCHEDULED': 'grey', 'UNKNOWN': 'purple'
                    }
                )
                fig_duration_vs_rows.update_layout(title_text='') # Remove title_text


                # Update axes for formatting/log scale
                if log_x_scatter:
                    fig_duration_vs_rows.update_xaxes(type='log')
                if log_y_scatter:
                    fig_duration_vs_rows.update_yaxes(type='log')
                
                # Apply number formatting for X-axis ticks (e.g. 1k, 1M)
                fig_duration_vs_rows.update_xaxes(tickformat=',.0s') # For millions, thousands etc.

                # Custom hovertemplate for scatter plot
                fig_duration_vs_rows.update_traces(
                    hovertemplate=(
                        '<b>Table: %{customdata[0]}</b><br>'
                        'State: %{customdata[1]}<br>'
                        f'{selected_row_metric_for_scatter}: %{{customdata[2]}}<br>'
                        'Duration: %{customdata[3]}<br>'
                        'Action: %{customdata[4]}<br>'
                        'Start: %{customdata[5]}<br>'
                        'End: %{customdata[6]}<br>'
                        'Message: %{customdata[7]}<br>'
                        '<extra></extra>'
                    ),
                    customdata=np.stack((
                        scatter_df['QUALIFIED_NAME'],
                        scatter_df['STATE'],
                        scatter_df['X_AXIS_METRIC_FMT_HOVER'],
                        scatter_df['REFRESH_DURATION_FMT_HOVER'], # Formatted hover value
                        scatter_df['REFRESH_ACTION'],
                        scatter_df['REFRESH_START_TIME_FMT'],
                        scatter_df['REFRESH_END_TIME_FMT'],
                        scatter_df['STATE_MESSAGE']
                    ), axis=-1)
                )
                
                st.plotly_chart(fig_duration_vs_rows, use_container_width=True)
            else:
                st.info(f"No valid data for Refresh Duration vs. {selected_row_metric_for_scatter} scatter plot after filters (considering zero/negative values for log scales). Please adjust filters.", icon="ℹ️")
        else:
            st.info("Necessary columns for Refresh Duration vs. Rows Processed analysis not available or no data after filters.", icon="ℹ️")
