with chart_cols_pair2[1]: # Refresh Duration vs. Rows Processed (Scatter Plot)
        st.markdown("<p style='font-size:16px;'><b>Refresh Duration vs. Rows Processed</b></p>", unsafe_allow_html=True)
        st.write("Examine if duration correlates with data volume.")
        
        all_row_metrics_scatter = {
            'Total Rows Changed': ['NUMINSERTEDROWS', 'NUMDELETEDROWS', 'NUMCOPIEDROWS', 'NUMADDEDPARTITIONS', 'NUMREMOVEDPARTITIONS'],
            'Inserted Rows': ['NUMINSERTEDROWS'],
            'Deleted Rows': ['NUMDELETEDROWS'],
            'Copied Rows': ['NUMCOPIEDROWS'],
            'Added Partitions': ['NUMADDEDPARTITIONS'],
            'Removed Partitions': ['NUMREMOVEDPARTITIONS']
        }
        
        available_row_metrics_scatter = {
            label: cols for label, cols in all_row_metrics_scatter.items()
            if all(c in filtered_history_df.columns for c in cols)
        }

        if 'REFRESH_DURATION_SEC' in filtered_history_df.columns and available_row_metrics_scatter:
            selected_row_metric_for_scatter = st.selectbox(
                "Select X-axis Row Metric:",
                options=list(available_row_metrics_scatter.keys()),
                key="scatter_x_axis_metric"
            )

            cols_to_sum = available_row_metrics_scatter[selected_row_metric_for_scatter]
            scatter_df = filtered_history_df.copy()
            scatter_df['X_AXIS_METRIC_VALUE'] = scatter_df[cols_to_sum].sum(axis=1)

            # --- START: FIX ---
            # The original dropna was too strict, especially on 'STATE_MESSAGE',
            # which is often NULL for successful runs. This filtered out most data.
            # We now drop only if essential axis values are missing.
            scatter_df = scatter_df.dropna(
                subset=['REFRESH_DURATION_SEC', 'X_AXIS_METRIC_VALUE']
            ).copy()

            # Explicitly fill NaN in columns used for the hover tooltip.
            # This prevents errors and preserves data points.
            for col in ['STATE_MESSAGE', 'REFRESH_ACTION', 'QUALIFIED_NAME', 'STATE']:
                if col in scatter_df.columns:
                    scatter_df[col] = scatter_df[col].fillna('N/A')
            # --- END: FIX ---
            
            # Log scale checkboxes (repositioned correctly within this column)
            log_scales_cols = st.columns([1, 1])
            with log_scales_cols[0]:
                log_x_scatter = st.checkbox("Log Scale X-axis", key="log_x_scatter_dt_state")
            with log_scales_cols[1]:
                log_y_scatter = st.checkbox("Log Scale Y-axis", key="log_y_scatter_dt_state")

            # Remove points where either X or Y is zero if log scale is to be applied
            if log_x_scatter or log_y_scatter:
                scatter_df = scatter_df[
                    (scatter_df['REFRESH_DURATION_SEC'] > 0) &
                    (scatter_df['X_AXIS_METRIC_VALUE'] > 0)
                ].copy()

            if not scatter_df.empty:
                # Format timestamps and duration for hover text
                scatter_df['REFRESH_START_TIME_FMT'] = scatter_df['REFRESH_START_TIME_DT'].dt.strftime('%Y-%m-%d %H:%M:%S').fillna("N/A")
                scatter_df['REFRESH_END_TIME_FMT'] = scatter_df['REFRESH_END_TIME_DT'].dt.strftime('%Y-%m-%d %H:%M:%S').fillna("N/A")
                scatter_df['REFRESH_DURATION_FMT_HOVER'] = format_seconds_to_readable(scatter_df['REFRESH_DURATION_SEC'], time_format_option)
                scatter_df['X_AXIS_METRIC_FMT_HOVER'] = scatter_df['X_AXIS_METRIC_VALUE'].apply(lambda x: f"{int(x):,}")


                fig_duration_vs_rows = px.scatter(
                    scatter_df,
                    x='X_AXIS_METRIC_VALUE',
                    y='REFRESH_DURATION_SEC',
                    color='STATE', # Color by refresh state
                    hover_data={
                        'QUALIFIED_NAME': False,
                        'STATE': False,
                        'REFRESH_ACTION': False,
                        'STATE_MESSAGE': False,
                        'REFRESH_START_TIME_DT': False,
                        'REFRESH_END_TIME_DT': False
                    },
                    title=f'Refresh Duration vs. {selected_row_metric_for_scatter}', # Redundant title
                    labels={
                        'REFRESH_DURATION_SEC': f'Duration ({time_format_option})', # Dynamic label
                        'X_AXIS_METRIC_VALUE': selected_row_metric_for_scatter
                    },
                    color_discrete_map={ # Explicitly map colors for consistency
                        'SUCCEEDED': 'blue', 'FAILED': 'red', 'UPSTREAM_FAILED': 'darkred',
                        'CANCELLED': 'orange', 'EXECUTING': 'green', 'SCHEDULED': 'grey', 'UNKNOWN': 'purple'
                    }
                )

                fig_duration_vs_rows.update_traces(
                    hovertemplate=(
                        '<b>Table: %{customdata[0]}</b><br>' # QUALIFIED_NAME from customdata
                        'State: %{customdata[1]}<br>'       # STATE from customdata
                        f'{selected_row_metric_for_scatter}: %{{customdata[2]}}<br>'
                        'Duration: %{customdata[3]}<br>'
                        'Action: %{customdata[4]}<br>'
                        'Start: %{customdata[5]}<br>'
                        'End: %{customdata[6]}<br>'
                        'Message: %{customdata[7]}<br>'
                        '<extra></extra>'
                    ),
                    customdata=np.stack((
                        scatter_df['QUALIFIED_NAME'],
                        scatter_df['STATE'],
                        scatter_df['X_AXIS_METRIC_FMT_HOVER'],
                        scatter_df['REFRESH_DURATION_FMT_HOVER'],
                        scatter_df['REFRESH_ACTION'],
                        scatter_df['REFRESH_START_TIME_FMT'],
                        scatter_df['REFRESH_END_TIME_FMT'],
                        scatter_df['STATE_MESSAGE']
                    ), axis=-1)
                )

                if log_x_scatter:
                    fig_duration_vs_rows.update_xaxes(type='log')
                if log_y_scatter:
                    fig_duration_vs_rows.update_yaxes(type='log')

                st.plotly_chart(fig_duration_vs_rows, use_container_width=True)
            else:
                st.info(f"No valid data for Refresh Duration vs. {selected_row_metric_for_scatter} scatter plot after filters (considering log scale requirements).", icon="ℹ️")
        else:
            st.info("Necessary columns for Refresh Duration vs. Rows Processed analysis not available or no data after filters.", icon="ℹ️")
