# ... (all your data prep code up to the plot remains the same) ...

if not scatter_df.empty:
    # --- Data Formatting for Hover (no changes here) ---
    scatter_df["REFRESH_START_TIME_FMT"] = (
        scatter_df["REFRESH_START_TIME_DT"]
        .dt.strftime("%Y-%m-%d %H:%M:%S")
        .fillna("N/A")
    )
    scatter_df["REFRESH_END_TIME_FMT"] = (
        scatter_df["REFRESH_END_TIME_DT"]
        .dt.strftime("%Y-%m-%d %H:%M:%S")
        .fillna("N/A")
    )
    scatter_df["REFRESH_DURATION_FMT_HOVER"] = format_seconds_to_readable(
        scatter_df["REFRESH_DURATION_SEC"], time_format_option
    )
    scatter_df["X_AXIS_METRIC_FMT_HOVER"] = scatter_df[
        "X_AXIS_METRIC_VALUE"
    ].apply(lambda x: f"{int(x):,}")
    scatter_df["STATE_MESSAGE_TRUNC"] = (
        scatter_df["STATE_MESSAGE"].str.slice(0, 100).fillna("N/A")
    )
    scatter_df.loc[
        scatter_df["STATE_MESSAGE"].str.len() > 100, "STATE_MESSAGE_TRUNC"
    ] += "..."

    # --- FIX: Pass custom_data directly into px.scatter ---
    fig_duration_vs_rows = px.scatter(
        scatter_df,
        x="X_AXIS_METRIC_VALUE",
        y="REFRESH_DURATION_SEC",
        color="STATE",
        labels={
            "REFRESH_DURATION_SEC": f"Duration ({time_format_option})",
            "X_AXIS_METRIC_VALUE": selected_row_metric_for_scatter,
        },
        color_discrete_map={
            "SUCCEEDED": "blue",
            "FAILED": "red",
            "UPSTREAM_FAILED": "darkred",
            "CANCELLED": "orange",
            "EXECUTING": "green",
            "SCHEDULED": "grey",
            "UNKNOWN": "purple",
        },
        # This is the key change. Pass the columns as a list.
        custom_data=[
            "QUALIFIED_NAME",
            "STATE",
            "X_AXIS_METRIC_FMT_HOVER",
            "REFRESH_DURATION_FMT_HOVER",
            "REFRESH_ACTION",
            "REFRESH_START_TIME_FMT",
            "REFRESH_END_TIME_FMT",
            "STATE_MESSAGE_TRUNC",
        ],
    )

    # --- FIX: Update the hovertemplate to use the new custom_data format ---
    # Note the syntax: %{custom_data[0]}, %{custom_data[1]}, etc.
    fig_duration_vs_rows.update_traces(
        hovertemplate=(
            "<b>Table: %{custom_data[0]}</b><br>"
            "State: %{custom_data[1]}<br>"
            f"{selected_row_metric_for_scatter}: %{{custom_data[2]}}<br>"
            "Duration: %{custom_data[3]}<br>"
            "Action: %{custom_data[4]}<br>"
            "Start: %{custom_data[5]}<br>"
            "End: %{custom_data[6]}<br>"
            "Message: %{custom_data[7]}<br>"
            "<extra></extra>"
        )
    )

    # Layout and axis logic remains the same and is correct
    fig_duration_vs_rows.update_layout(
        legend=dict(
            title_text="State",
            orientation="h",
            yanchor="bottom",
            y=1.02,
            xanchor="right",
            x=1,
        ),
        margin=dict(l=50, r=20, t=40, b=50),
    )

    if log_x_scatter:
        fig_duration_vs_rows.update_xaxes(type="log", automargin=True)
    else:
        fig_duration_vs_rows.update_xaxes(type="linear", automargin=True)

    if log_y_scatter:
        fig_duration_vs_rows.update_yaxes(type="log", automargin=True)
    else:
        fig_duration_vs_rows.update_yaxes(type="linear", automargin=True)

    st.plotly_chart(fig_duration_vs_rows, use_container_width=True)

else:  # This branch handles cases where scatter_df became empty
    st.info(
        f"No valid data points available for Refresh Duration vs. {selected_row_metric_for_scatter} scatter plot after filters. Please adjust filters.",
        icon="ℹ️",
    )
