with chart_cols_pair2[1]: # Refresh Duration vs. Rows Processed (Scatter Plot)
        st.markdown("<p style='font-size:16px;'><b>Refresh Duration vs. Rows Processed</b></p>", unsafe_allow_html=True)
        st.write("Examine if duration correlates with data volume.")
        
        all_row_metrics_scatter = {
            'Total Rows Changed': ['NUMINSERTEDROWS', 'NUMDELETEDROWS', 'NUMCOPIEDROWS', 'NUMADDEDPARTITIONS', 'NUMREMOVEDPARTITIONS'],
            'Inserted Rows': ['NUMINSERTEDROWS'],
            'Deleted Rows': ['NUMDELETEDROWS'],
            'Copied Rows': ['NUMCOPIEDROWS'],
            'Added Partitions': ['NUMADDEDPARTITIONS'],
            'Removed Partitions': ['NUMREMOVEDPARTITIONS']
        }
        
        available_row_metrics_scatter = {
            label: cols for label, cols in all_row_metrics_scatter.items()
            if all(c in filtered_history_df.columns for c in cols)
        }

        if 'REFRESH_DURATION_SEC' in filtered_history_df.columns and available_row_metrics_scatter:
            selected_row_metric_for_scatter = st.selectbox(
                "Select X-axis Row Metric:",
                options=list(available_row_metrics_scatter.keys()),
                key="scatter_x_axis_metric"
            )

            cols_to_sum = available_row_metrics_scatter[selected_row_metric_for_scatter]
            
            # --- START SCATTER PLOT REBUILD ---
            # Create the scatter_df with necessary columns for plotting and hover
            scatter_df = filtered_history_df.copy()

            # Calculate X-axis metric value
            scatter_df['X_AXIS_METRIC_VALUE'] = scatter_df[cols_to_sum].sum(axis=1)

            # --- TRANSFORM Y-AXIS DATA TO SELECTED DISPLAY UNIT FOR PLOTTING ---
            if time_format_option == 'minutes':
                scatter_df['Y_AXIS_PLOT_VALUE'] = scatter_df['REFRESH_DURATION_SEC'] / 60
            elif time_format_option == 'hours':
                scatter_df['Y_AXIS_PLOT_VALUE'] = scatter_df['REFRESH_DURATION_SEC'] / 3600
            elif time_format_option == 'days':
                scatter_df['Y_AXIS_PLOT_VALUE'] = scatter_df['REFRESH_DURATION_SEC'] / 86400
            else: # Default to seconds or mixed if other options (mixed will plot seconds)
                scatter_df['Y_AXIS_PLOT_VALUE'] = scatter_df['REFRESH_DURATION_SEC']

            # Drop NaNs critical for plotting (after Y_AXIS_PLOT_VALUE is created)
            # Ensure these columns exist before dropping (already checked by available_row_metrics_scatter)
            scatter_df = scatter_df.dropna(subset=['Y_AXIS_PLOT_VALUE', 'X_AXIS_METRIC_VALUE', 'QUALIFIED_NAME', 'STATE', 'REFRESH_ACTION', 'REFRESH_START_TIME_DT', 'REFRESH_END_TIME_DT', 'STATE_MESSAGE']).copy()

            # Filter out 'NO_DATA' actions for better insight on this plot (as in previous working versions)
            scatter_df = scatter_df[scatter_df['REFRESH_ACTION'] != 'NO_DATA'].copy()

            # --- LOG SCALE CHECKBOXES & ZERO/NEGATIVE VALUE HANDLING ---
            # These must be defined before their values are used for filtering
            log_scales_cols = st.columns([1, 1])
            with log_scales_cols[0]:
                log_x_scatter = st.checkbox("Log X-axis", key="log_x_scatter_dt_state")
            with log_scales_cols[1]:
                log_y_scatter = st.checkbox("Log Y-axis", key="log_y_scatter_dt_state")

            if log_x_scatter or log_y_scatter:
                initial_count = len(scatter_df)
                scatter_df = scatter_df[
                    (scatter_df['Y_AXIS_PLOT_VALUE'] > 0) & # Filter on the converted Y-axis value
                    (scatter_df['X_AXIS_METRIC_VALUE'] > 0)
                ].copy()
                if len(scatter_df) < initial_count:
                    st.info(f"Note: {initial_count - len(scatter_df)} data point(s) with zero/negative values were excluded for log scale display.", icon="ℹ️")


            if not scatter_df.empty:
                # --- PREPARE HOVER DATA ---
                # These columns are for hover *display* and should always be derived from original data
                scatter_df['REFRESH_START_TIME_FMT'] = scatter_df['REFRESH_START_TIME_DT'].dt.strftime('%Y-%m-%d %H:%M:%S').fillna("N/A")
                scatter_df['REFRESH_END_TIME_FMT'] = scatter_df['REFRESH_END_TIME_DT'].dt.strftime('%Y-%m-%d %H:%M:%S').fillna("N/A")
                
                # REFRESH_DURATION_FMT_HOVER will still use the original SECONDS for consistent format_seconds_to_readable output
                scatter_df['REFRESH_DURATION_FMT_HOVER'] = format_seconds_to_readable(scatter_df['REFRESH_DURATION_SEC'], time_format_option)
                scatter_df['X_AXIS_METRIC_FMT_HOVER'] = scatter_df['X_AXIS_METRIC_VALUE'].apply(lambda x: f"{int(x):,}")


                fig_duration_vs_rows = px.scatter(
                    scatter_df,
                    x='X_AXIS_METRIC_VALUE', # Plotting X in raw value
                    y='Y_AXIS_PLOT_VALUE',   # PLOTTING THE CONVERTED Y-AXIS VALUE
                    color='STATE', # Color by refresh state
                    # Explicitly control hover data via customdata
                    hover_data={
                        'QUALIFIED_NAME': False, 'STATE': False, 'REFRESH_ACTION': False,
                        'STATE_MESSAGE': False, 'REFRESH_START_TIME_DT': False, 'REFRESH_END_TIME_DT': False
                    },
                    # --- AXIS LABELS ---
                    labels={
                        'Y_AXIS_PLOT_VALUE': f'Duration ({time_format_option})', # Dynamic Y-axis label
                        'X_AXIS_METRIC_VALUE': selected_row_metric_for_scatter
                    },
                    color_discrete_map={ # Explicitly map colors for consistency
                        'SUCCEEDED': 'blue', 'FAILED': 'red', 'UPSTREAM_FAILED': 'darkred',
                        'CANCELLED': 'orange', 'EXECUTING': 'green', 'SCHEDULED': 'grey', 'UNKNOWN': 'purple'
                    }
                )
                fig_duration_vs_rows.update_layout(title_text='') # Remove title_text


                # --- UPDATE AXES FOR FORMATTING/LOG SCALE ---
                if log_x_scatter:
                    fig_duration_vs_rows.update_xaxes(type='log', rangemode='tozero')
                else: # Default linear and standard tick formatting for X
                    fig_duration_vs_rows.update_xaxes(type='linear', tickformat=',.0s') # E.g., 100, 1k, 1M, 1G
                
                if log_y_scatter:
                    fig_duration_vs_rows.update_yaxes(type='log', rangemode='tozero')
                else: # Default linear and custom tick text for Y if not seconds
                    # For Y-axis, Plotly's tickformat does not handle 'mixed' or '1m' well.
                    # We need to explicitly calculate tick values in the PLOTTING unit (Y_AXIS_PLOT_VALUE)
                    # and format their text for display.
                    if time_format_option != 'seconds':
                        min_y_val = fig_duration_vs_rows.layout.yaxis.range[0] if fig_duration_vs_rows.layout.yaxis.range else scatter_df['Y_AXIS_PLOT_VALUE'].min()
                        max_y_val = fig_duration_vs_rows.layout.yaxis.range[1] if fig_duration_vs_rows.layout.yaxis.range else scatter_df['Y_AXIS_PLOT_VALUE'].max()
                        
                        if max_y_val > min_y_val and max_y_val > 0:
                            num_ticks = 5 # Default number of ticks
                            tick_values_converted_unit = np.linspace(min_y_val, max_y_val, num=num_ticks, endpoint=True)
                            
                            # Convert these tick values BACK to seconds for format_seconds_to_readable
                            if time_format_option == 'minutes':
                                tick_values_seconds = tick_values_converted_unit * 60
                            elif time_format_option == 'hours':
                                tick_values_seconds = tick_values_converted_unit * 3600
                            elif time_format_option == 'days':
                                tick_values_seconds = tick_values_converted_unit * 86400
                            else: # Should be seconds if format is seconds
                                tick_values_seconds = tick_values_converted_unit
                            
                            tick_texts_formatted = format_seconds_to_readable(pd.Series(tick_values_seconds), time_format_option).tolist()
                            fig_duration_vs_rows.update_yaxes(tickvals=tick_values_converted_unit, ticktext=tick_texts_formatted)
                        else: # Fallback for edge cases with zero/min data
                            fig_duration_vs_rows.update_yaxes(type='linear', tickformat=".1f") # Simple float format
                    else: # If seconds, use a standard tickformat for seconds
                        fig_duration_vs_rows.update_yaxes(type='linear', tickformat=".1f", ticksuffix="s")

                # --- Custom hovertemplate for scatter plot ---
                fig_duration_vs_rows.update_traces(
                    hovertemplate=(
                        '<b>Table: %{customdata[0]}</b><br>' # QUALIFIED_NAME from customdata
                        'State: %{customdata[1]}<br>'       # STATE from customdata
                        f'{selected_row_metric_for_scatter}: %{{customdata[2]}}<br>'
                        'Duration: %{customdata[3]}<br>' # This now matches the hover value for duration
                        'Action: %{customdata[4]}<br>'
                        'Start: %{customdata[5]}<br>'
                        'End: %{customdata[6]}<br>'
                        'Message: %{customdata[7]}<br>'
                        '<extra></extra>'
                    ),
                    customdata=np.stack((
                        scatter_df['QUALIFIED_NAME'],
                        scatter_df['STATE'],
                        scatter_df['X_AXIS_METRIC_FMT_HOVER'],
                        scatter_df['REFRESH_DURATION_FMT_HOVER'], # Formatted duration for hover
                        scatter_df['REFRESH_ACTION'],
                        scatter_df['REFRESH_START_TIME_FMT'],
                        scatter_df['REFRESH_END_TIME_FMT'],
                        scatter_df['STATE_MESSAGE']
                    ), axis=-1)
                )
                
                st.plotly_chart(fig_duration_vs_rows, use_container_width=True)
            else:
                st.info(f"No valid data for Refresh Duration vs. {selected_row_metric_for_scatter} scatter plot after filters (considering zero/negative values for log scales). Please adjust filters.", icon="ℹ️")
        else:
            st.info("Necessary columns for Refresh Duration vs. Rows Processed analysis not available or no data after filters.", icon="ℹ️")
    
    st.divider()
