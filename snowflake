-- CREATE TABLE STATEMENT for T_DYNAMIC_TABLE_TRACKING
-- Run this ONCE in your Snowflake environment.
-- Replace YOUR_DB and YOUR_SCHEMA.

CREATE TABLE YOUR_DB.YOUR_SCHEMA.T_DYNAMIC_TABLE_TRACKING (
    ID NUMBER AUTOINCREMENT, -- Incremental ID for tracking record
    DATABASE_NAME TEXT NOT NULL,
    SCHEMA_NAME TEXT NOT NULL,
    TABLE_NAME TEXT NOT NULL,
    QUALIFIED_NAME TEXT AS (DATABASE_NAME || '.' || SCHEMA_NAME || '.' || TABLE_NAME) UNIQUE, -- Auto-generate and ensure uniqueness
    
    -- Tracking Flags for specific data types
    TRACK_REFRESH_HISTORY BOOLEAN DEFAULT TRUE, -- Collects from DYNAMIC_TABLE_REFRESH_HISTORY
    TRACK_METADATA_SNAPSHOT BOOLEAN DEFAULT FALSE, -- Collects from DYNAMIC_TABLES (current state)
    TRACK_GRAPH_HISTORY BOOLEAN DEFAULT FALSE, -- Placeholder if you later want to collect from DYNAMIC_TABLE_GRAPH_HISTORY
    
    IS_ACTIVE BOOLEAN DEFAULT TRUE, -- Set to FALSE to disable tracking for a table

    -- Collection Parameters for DYNAMIC_TABLE_REFRESH_HISTORY
    COLLECT_REFRESH_HISTORY_DAYS NUMBER DEFAULT 7, -- P_COLLECT_FROM_LAST_DAYS for refresh history

    -- Collection Parameters for DYNAMIC_TABLES (Metadata Snapshot)
    -- This collection currently has no explicit date range, so 'DAYS' here is more conceptual for logging.
    -- DYNAMIC_TABLES by default shows within 7 days, if not specified.
    COLLECT_METADATA_DAYS NUMBER DEFAULT 7, 

    -- Audit and Status for REFRESH_HISTORY collection
    LAST_REFRESH_HISTORY_COLLECTION_TIMESTAMP TIMESTAMP_NTZ,
    LAST_REFRESH_HISTORY_COLLECTION_STATUS TEXT, -- SUCCESS / FAILED
    LAST_REFRESH_HISTORY_COLLECTION_MESSAGE TEXT,

    -- Audit and Status for METADATA_SNAPSHOT collection
    LAST_METADATA_COLLECTION_TIMESTAMP TIMESTAMP_NTZ,
    LAST_METADATA_COLLECTION_STATUS TEXT,
    LAST_METADATA_COLLECTION_MESSAGE TEXT,

    CREATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
    UPDATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- Example initial population (add all existing dynamic tables to tracking if not already there)
-- Run this once or periodically to synchronize.
INSERT INTO YOUR_DB.YOUR_SCHEMA.T_DYNAMIC_TABLE_TRACKING (DATABASE_NAME, SCHEMA_NAME, TABLE_NAME)
SELECT DATABASE_NAME, SCHEMA_NAME, NAME FROM INFORMATION_SCHEMA.DYNAMIC_TABLES(RESULT_LIMIT => 10000) -- Increased limit for getting all DTs
ON CONFLICT (QUALIFIED_NAME) DO UPDATE SET UPDATED_AT = CURRENT_TIMESTAMP();





=====================================================
-- CREATE TABLE STATEMENT for T_DYNAMIC_TABLE_METADATA_LATEST_SNAPSHOT
-- This table stores the LATEST collected metadata snapshot for each dynamic table.
-- Replace YOUR_DB and YOUR_SCHEMA.

CREATE TABLE YOUR_DB.YOUR_SCHEMA.T_DYNAMIC_TABLE_METADATA_LATEST_SNAPSHOT (
    COLLECTION_TIMESTAMP TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(), -- When this record was captured
    DATABASE_NAME TEXT,
    SCHEMA_NAME TEXT,
    TABLE_NAME TEXT,
    QUALIFIED_NAME TEXT PRIMARY KEY, -- QUALIFIED_NAME is the primary key as it's the latest snapshot
    
    TARGET_LAG_SEC NUMBER,
    TARGET_LAG_TYPE TEXT,
    
    SCHEDULING_STATE_STATUS TEXT,
    SCHEDULING_STATE_REASON_CODE TEXT,
    SCHEDULING_STATE_REASON_MESSAGE TEXT,
    SCHEDULING_STATE_SUSPENDED_ON TIMESTAMP_NTZ,
    SCHEDULING_STATE_RESUMED_ON TIMESTAMP_NTZ,

    MEAN_LAG_SEC NUMBER,
    MAXIMUM_LAG_SEC NUMBER,
    TIME_ABOVE_TARGET_LAG_SEC NUMBER,
    TIME_WITHIN_TARGET_LAG_RATIO NUMBER,
    LATEST_DATA_TIMESTAMP TIMESTAMP_NTZ,
    
    LAST_COMPLETED_REFRESH_STATE TEXT,
    LAST_COMPLETED_REFRESH_STATE_CODE TEXT,
    LAST_COMPLETED_REFRESH_STATE_MESSAGE TEXT,
    EXECUTING_REFRESH_QUERY_ID TEXT
);


=================================================

-- Main Driver Stored Procedure - Orchestrates collection for all tracked tables
-- Replace YOUR_DB and YOUR_SCHEMA.

CREATE OR REPLACE PROCEDURE YOUR_DB.YOUR_SCHEMA.SP_DRIVE_ALL_DT_COLLECTION()
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS
$$
DECLARE
    lv_message VARCHAR DEFAULT '';
    lv_record_count INTEGER DEFAULT 0;
    lv_processed_count INTEGER DEFAULT 0;
    lv_success_count INTEGER DEFAULT 0;
    lv_fail_count INTEGER DEFAULT 0;
    lv_db_name VARCHAR;
    lv_schema_name VARCHAR;
    lv_table_name VARCHAR;
    lv_qualified_name VARCHAR;
    lv_track_refresh_history BOOLEAN;
    lv_track_metadata_snapshot BOOLEAN;
    lv_track_graph_history BOOLEAN; -- Not implemented yet, but included in schema
    lv_refresh_history_days NUMBER;
    lv_metadata_days NUMBER;
    lv_call_result VARCHAR;

    -- Cursor to select active tables needing collection
    c_tables CURSOR FOR
        SELECT 
            DATABASE_NAME, SCHEMA_NAME, TABLE_NAME, QUALIFIED_NAME,
            TRACK_REFRESH_HISTORY, TRACK_METADATA_SNAPSHOT, TRACK_GRAPH_HISTORY,
            COLLECT_REFRESH_HISTORY_DAYS, COLLECT_METADATA_DAYS
        FROM YOUR_DB.YOUR_SCHEMA.T_DYNAMIC_TABLE_TRACKING
        WHERE IS_ACTIVE = TRUE; -- Only process active tables

BEGIN
    lv_message := lv_message || 'Starting DYNAMIC TABLE COLLECTION DRIVER at ' || CURRENT_TIMESTAMP() || '\n';
    
    OPEN c_tables;
    LOOP
        FETCH c_tables INTO lv_db_name, lv_schema_name, lv_table_name, lv_qualified_name,
                             lv_track_refresh_history, lv_track_metadata_snapshot, lv_track_graph_history,
                             lv_refresh_history_days, lv_metadata_days;
        IF (c_tables%NOTFOUND) THEN
            BREAK; -- Exit loop when no more records
        END IF;

        lv_record_count := lv_record_count + 1; -- Count total records in cursor

        BEGIN -- Inner BEGIN/END block for per-table error handling
            lv_processed_count := lv_processed_count + 1;
            lv_message := lv_message || '  Processing table: ' || lv_qualified_name || '\n';

            -- Call SP_COLLECT_DT_REFRESH_HISTORY (for detailed event history)
            IF (lv_track_refresh_history) THEN
                lv_call_result := '';
                CALL YOUR_DB.YOUR_SCHEMA.SP_COLLECT_DT_REFRESH_HISTORY(
                    :lv_db_name,
                    :lv_schema_name,
                    :lv_table_name,
                    :lv_refresh_history_days
                ) INTO lv_call_result;

                IF (STARTSWITH(lv_call_result, 'ERROR')) THEN
                    lv_message := lv_message || '    Refresh History FAILED: ' || lv_call_result || '\n';
                    UPDATE YOUR_DB.YOUR_SCHEMA.T_DYNAMIC_TABLE_TRACKING
                    SET 
                        LAST_REFRESH_HISTORY_COLLECTION_TIMESTAMP = CURRENT_TIMESTAMP()::TIMESTAMP_NTZ,
                        LAST_REFRESH_HISTORY_COLLECTION_STATUS = 'FAILED',
                        LAST_REFRESH_HISTORY_COLLECTION_MESSAGE = :lv_call_result,
                        UPDATED_AT = CURRENT_TIMESTAMP()::TIMESTAMP_NTZ
                    WHERE QUALIFIED_NAME = :lv_qualified_name;
                    lv_fail_count := lv_fail_count + 1; -- Increment fail count for this call type
                ELSE
                    lv_message := lv_message || '    Refresh History SUCCESS: ' || lv_call_result || '\n';
                    UPDATE YOUR_DB.YOUR_SCHEMA.T_DYNAMIC_TABLE_TRACKING
                    SET 
                        LAST_REFRESH_HISTORY_COLLECTION_TIMESTAMP = CURRENT_TIMESTAMP()::TIMESTAMP_NTZ,
                        LAST_REFRESH_HISTORY_COLLECTION_STATUS = 'SUCCESS',
                        LAST_REFRESH_HISTORY_COLLECTION_MESSAGE = :lv_call_result,
                        UPDATED_AT = CURRENT_TIMESTAMP()::TIMESTAMP_NTZ
                    WHERE QUALIFIED_NAME = :lv_qualified_name;
                END IF;
            END IF;

            -- Call SP_COLLECT_DYNAMIC_TABLE_METADATA (for current metadata snapshot)
            IF (lv_track_metadata_snapshot) THEN
                lv_call_result := '';
                CALL YOUR_DB.YOUR_SCHEMA.SP_COLLECT_DYNAMIC_TABLE_METADATA(
                    :lv_db_name,
                    :lv_schema_name,
                    :lv_table_name
                ) INTO lv_call_result;

                IF (STARTSWITH(lv_call_result, 'ERROR')) THEN
                    lv_message := lv_message || '    Metadata Snapshot FAILED: ' || lv_call_result || '\n';
                    UPDATE YOUR_DB.YOUR_SCHEMA.T_DYNAMIC_TABLE_TRACKING
                    SET 
                        LAST_METADATA_COLLECTION_TIMESTAMP = CURRENT_TIMESTAMP()::TIMESTAMP_NTZ,
                        LAST_METADATA_COLLECTION_STATUS = 'FAILED',
                        LAST_METADATA_COLLECTION_MESSAGE = :lv_call_result,
                        UPDATED_AT = CURRENT_TIMESTAMP()::TIMESTAMP_NTZ
                    WHERE QUALIFIED_NAME = :lv_qualified_name;
                    lv_fail_count := lv_fail_count + 1; -- Increment fail count for this call type
                ELSE
                    lv_message := lv_message || '    Metadata Snapshot SUCCESS: ' || lv_call_result || '\n';
                    UPDATE YOUR_DB.YOUR_SCHEMA.T_DYNAMIC_TABLE_TRACKING
                    SET 
                        LAST_METADATA_COLLECTION_TIMESTAMP = CURRENT_TIMESTAMP()::TIMESTAMP_NTZ,
                        LAST_METADATA_COLLECTION_STATUS = 'SUCCESS',
                        LAST_METADATA_COLLECTION_MESSAGE = :lv_call_result,
                        UPDATED_AT = CURRENT_TIMESTAMP()::TIMESTAMP_NTZ
                    WHERE QUALIFIED_NAME = :lv_qualified_name;
                END IF;
            END IF;

            -- Add logic for TRACK_GRAPH_HISTORY if you implement that procedure later
            -- IF (lv_track_graph_history) THEN
            --    CALL YOUR_DB.YOUR_SCHEMA.SP_COLLECT_DT_GRAPH_HISTORY(...)
            --    ...
            -- END IF;

            lv_success_count := lv_success_count + 1; -- Increment success count for entire table processing (if any tracked task for it passed)

        EXCEPTION
            WHEN OTHER THEN
                lv_fail_count := lv_fail_count + 1; -- General processing failure for this table
                lv_error_message := 'UNEXPECTED ERROR processing ' || lv_qualified_name || ': ' || SQLERRM();
                lv_message := lv_message || '    ' || lv_error_message || '\n';
        END; -- End inner BEGIN/END block
    END LOOP;
    CLOSE c_tables;

    lv_message := lv_message || 'DYNAMIC TABLE COLLECTION DRIVER finished at ' || CURRENT_TIMESTAMP() || '\n';
    lv_message := lv_message || 'Total tables found: ' || lv_record_count || ', Processed attempts: ' || lv_processed_count || ', Overall Success: ' || lv_success_count || ', Overall Failed: ' || lv_fail_count || '\n';
    RETURN lv_message;

EXCEPTION
    WHEN OTHER THEN
        lv_error_message := 'Major Error in DYNAMIC TABLE COLLECTION DRIVER: ' || SQLERRM();
        RETURN lv_error_message;
END;
$$;


====================================================

-- CREATE STORED PROCEDURE STATEMENT - Collects DYNAMIC_TABLES metadata
-- UPDATED for strict input handling: REQUIRES a fully qualified name for collection.
-- Replace YOUR_DB and YOUR_SCHEMA.

CREATE OR REPLACE PROCEDURE YOUR_DB.YOUR_SCHEMA.SP_COLLECT_DYNAMIC_TABLE_METADATA(
    P_DATABASE_NAME VARCHAR, -- Changed to accept separate components
    P_SCHEMA_NAME VARCHAR,   -- Changed to accept separate components
    P_TABLE_NAME VARCHAR     -- Changed to accept separate components
)
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS
$$
DECLARE
    lv_func_args VARCHAR := '';
    lv_merge_action_desc VARCHAR;
    lv_error_message VARCHAR;
    lv_records_fetched INTEGER;
    lv_filter_provided BOOLEAN := FALSE; -- Flag to track if a valid filter was constructed
    lv_qualified_name_to_filter VARCHAR; -- To hold the resolved qualified name for strict post-query filter
BEGIN
    -- Strict Input Validation: REQUIRES all three components to be non-NULL and non-empty.
    -- This is the core change to enforce strict qualified name input for DYNAMIC_TABLES.
    IF (P_DATABASE_NAME IS NOT NULL AND TRIM(P_DATABASE_NAME) != '' AND
        P_SCHEMA_NAME IS NOT NULL AND TRIM(P_SCHEMA_NAME) != '' AND
        P_TABLE_NAME IS NOT NULL AND TRIM(P_TABLE_NAME) != '') THEN
        
        lv_qualified_name_to_filter := :P_DATABASE_NAME || '.' || :P_SCHEMA_NAME || '.' || :P_TABLE_NAME;
        lv_func_args := 'NAME => ''' || :lv_qualified_name_to_filter || ''''; -- Pass fully qualified name to NAME arg
        lv_filter_provided := TRUE;
    ELSE
        -- If the strict condition is not met, return an error.
        RETURN 'ERROR: All of P_DATABASE_NAME, P_SCHEMA_NAME, AND P_TABLE_NAME must be provided and non-empty for DYNAMIC_TABLES collection.';
    END IF;

    -- DYNAMIC_TABLES function does not have a NAME_PREFIX argument or direct filtering options for partial names.
    -- It only takes 'NAME'. If NAME is not used, it defaults to 100 results.
    -- We must enforce getting exactly what was asked for.

    EXECUTE IMMEDIATE '
        MERGE INTO YOUR_DB.YOUR_SCHEMA.T_DYNAMIC_TABLE_METADATA_LATEST_SNAPSHOT AS target_table
        USING (
            SELECT
                CURRENT_TIMESTAMP()::TIMESTAMP_NTZ AS COLLECTION_TIMESTAMP_SOURCE,
                dt.DATABASE_NAME,
                dt.SCHEMA_NAME,
                dt.NAME AS TABLE_NAME,
                dt.QUALIFIED_NAME,
                dt.TARGET_LAG_SEC,
                dt.TARGET_LAG_TYPE,
                
                dt.SCHEDULING_STATE:STATE::TEXT AS SCHEDULING_STATE_STATUS,
                dt.SCHEDULING_STATE:REASON_CODE::TEXT AS SCHEDULING_STATE_REASON_CODE,
                dt.SCHEDULING_STATE:REASON_MESSAGE::TEXT AS SCHEDULING_STATE_REASON_MESSAGE,
                dt.SCHEDULING_STATE:SUSPENDED_ON::TIMESTAMP_NTZ AS SCHEDULING_STATE_SUSPENDED_ON,
                dt.SCHEDULING_STATE:RESUMED_ON::TIMESTAMP_NTZ AS SCHEDULING_STATE_RESUMED_ON,

                dt.MEAN_LAG_SEC,
                dt.MAXIMUM_LAG_SEC,
                dt.TIME_ABOVE_TARGET_LAG_SEC,
                dt.TIME_WITHIN_TARGET_LAG_RATIO,
                dtrh.LATEST_DATA_TIMESTAMP::TIMESTAMP_NTZ AS LATEST_DATA_TIMESTAMP,
                dtrh.LAST_COMPLETED_REFRESH_STATE,
                dtrh.LAST_COMPLETED_REFRESH_STATE_CODE,
                dtrh.LAST_COMPLETED_REFRESH_STATE_MESSAGE,
                dtrh.EXECUTING_REFRESH_QUERY_ID
            FROM
                TABLE(INFORMATION_SCHEMA.DYNAMIC_TABLES(' || lv_func_args || ')) dtrh
            WHERE dtrh.QUALIFIED_NAME = ''' || :lv_qualified_name_to_filter || ''' -- Strict filter post-function call
        ) AS source_data
        ON target_table.QUALIFIED_NAME = source_data.QUALIFIED_NAME

        WHEN MATCHED THEN
            UPDATE SET
                target_table.COLLECTION_TIMESTAMP = source_data.COLLECTION_TIMESTAMP_SOURCE,
                target_table.DATABASE_NAME = source_data.DATABASE_NAME,
                target_table.SCHEMA_NAME = source_data.SCHEMA_NAME,
                target_table.TABLE_NAME = source_data.TABLE_NAME,
                target_table.TARGET_LAG_SEC = source_data.TARGET_LAG_SEC,
                target_table.TARGET_LAG_TYPE = source_data.TARGET_LAG_TYPE,
                target_table.SCHEDULING_STATE_STATUS = source_data.SCHEDULING_STATE_STATUS,
                target_table.SCHEDULING_STATE_REASON_CODE = source_data.SCHEDULING_STATE_REASON_CODE,
                target_table.SCHEDULING_STATE_REASON_MESSAGE = source_data.SCHEDULING_STATE_REASON_MESSAGE,
                target_table.SCHEDULING_STATE_SUSPENDED_ON = source_data.SCHEDULING_STATE_SUSPENDED_ON,
                target_table.SCHEDULING_STATE_RESUMED_ON = source_data.SCHEDULING_STATE_RESUMED_ON,
                target_table.MEAN_LAG_SEC = source_data.MEAN_LAG_SEC,
                target_table.MAXIMUM_LAG_SEC = source_data.MAXIMUM_LAG_SEC,
                target_table.TIME_ABOVE_TARGET_LAG_SEC = source_data.TIME_ABOVE_TARGET_LAG_SEC,
                target_table.TIME_WITHIN_TARGET_LAG_RATIO = source_data.TIME_WITHIN_TARGET_LAG_RATIO,
                target_table.LATEST_DATA_TIMESTAMP = source_data.LATEST_DATA_TIMESTAMP,
                target_table.LAST_COMPLETED_REFRESH_STATE = source_data.LAST_COMPLETED_REFRESH_STATE,
                target_table.LAST_COMPLETED_REFRESH_STATE_CODE = source_data.LAST_COMPLETED_REFRESH_STATE_CODE,
                target_table.LAST_COMPLETED_REFRESH_STATE_MESSAGE = source_data.LAST_COMPLETED_REFRESH_STATE_MESSAGE,
                target_table.EXECUTING_REFRESH_QUERY_ID = source_data.EXECUTING_REFRESH_QUERY_ID
        WHEN NOT MATCHED THEN
            INSERT (
                COLLECTION_TIMESTAMP,
                DATABASE_NAME, SCHEMA_NAME, TABLE_NAME, QUALIFIED_NAME,
                TARGET_LAG_SEC, TARGET_LAG_TYPE,
                SCHEDULING_STATE_STATUS, SCHEDULING_STATE_REASON_CODE, SCHEDULING_STATE_REASON_MESSAGE,
                SCHEDULING_STATE_SUSPENDED_ON, SCHEDULING_STATE_RESUMED_ON,
                MEAN_LAG_SEC, MAXIMUM_LAG_SEC, TIME_ABOVE_TARGET_LAG_SEC, TIME_WITHIN_TARGET_LAG_RATIO,
                LATEST_DATA_TIMESTAMP, LAST_COMPLETED_REFRESH_STATE, LAST_COMPLETED_REFRESH_STATE_CODE,
                LAST_COMPLETED_REFRESH_STATE_MESSAGE, EXECUTING_REFRESH_QUERY_ID
            )
            VALUES (
                source_data.COLLECTION_TIMESTAMP_SOURCE,
                source_data.DATABASE_NAME, source_data.SCHEMA_NAME, source_data.TABLE_NAME, source_data.QUALIFIED_NAME,
                source_data.TARGET_LAG_SEC, source_data.TARGET_LAG_TYPE,
                source_data.SCHEDULING_STATE_STATUS, source_data.SCHEDULING_STATE_REASON_CODE, source_data.SCHEDULING_STATE_REASON_MESSAGE,
                source_data.SCHEDULING_STATE_SUSPENDED_ON, source_data.SCHEDULING_STATE_RESUMED_ON,
                source_data.MEAN_LAG_SEC, source_data.MAXIMUM_LAG_SEC, source_data.TIME_ABOVE_TARGET_LAG_SEC, source_data.TIME_WITHIN_TARGET_LAG_RATIO,
                source_data.LATEST_DATA_TIMESTAMP, source_data.LAST_COMPLETED_REFRESH_STATE, source_data.LAST_COMPLETED_REFRESH_STATE_CODE,
                source_data.LAST_COMPLETED_REFRESH_STATE_MESSAGE, source_data.EXECUTING_REFRESH_QUERY_ID
            );
    ';

    SELECT
        "number of rows inserted" || ' inserted, ' ||
        "number of rows updated" || ' updated.'
    INTO lv_merge_action_desc
    FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

    RETURN 'Successfully merged ' || lv_merge_action_desc || ' into T_DYNAMIC_TABLE_METADATA_LATEST_SNAPSHOT for ' || :lv_qualified_name_to_filter || '.';

EXCEPTION
    WHEN OTHER THEN
        lv_error_message := 'Error during DYNAMIC_TABLES metadata collection for ' || COALESCE(:P_DATABASE_NAME, 'N/A') || '.' || COALESCE(:P_SCHEMA_NAME, 'N/A') || '.' || COALESCE(:P_TABLE_NAME, 'N/A') || '. SQLSTATE: ' || SQLSTATE() || ', SQLCODE: ' || SQLCODE() || ', Message: ' || SQLERRM();
        RETURN lv_error_message;
END;
$$;
