CREATE OR REPLACE PROCEDURE YOUR_DB.YOUR_SCHEMA.SP_COLLECT_DYNAMIC_TABLE_METADATA(
    P_DATABASE_NAME VARCHAR,
    P_SCHEMA_NAME VARCHAR,
    P_TABLE_NAME VARCHAR,
    P_DATA_STAGING_TABLE_FQDN VARCHAR,
    P_TRACKING_STAGING_TABLE_FQDN VARCHAR,
    P_RUN_UUID VARCHAR
)
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS
$$
DECLARE
    lv_func_args VARCHAR := '';
    lv_records_fetched INTEGER;
    lv_qualified_name_to_filter VARCHAR;
    lv_collection_current_time TIMESTAMP_LTZ := CURRENT_TIMESTAMP();

    lv_status VARCHAR;
    lv_message VARCHAR;

    -- NEW: Declare custom exceptions
    E_INPUT_VALIDATION_FAILED EXCEPTION (-20003, 'Input Validation Failed for Metadata Collection');
    E_COLLECTION_EXECUTION_FAILED EXCEPTION (-20004, 'Data Collection Execution Failed for Metadata');

BEGIN
    lv_qualified_name_to_filter := :P_DATABASE_NAME || '.' || :P_SCHEMA_NAME || '.' || :P_TABLE_NAME;
    lv_status := 'SUCCESS';
    lv_message := 'Successfully collected data into staging.';

    BEGIN -- Inner block for data collection specific errors
        IF (P_DATABASE_NAME IS NULL OR TRIM(P_DATABASE_NAME) = '' OR
            P_SCHEMA_NAME IS NULL OR TRIM(P_SCHEMA_NAME) = '' OR
            P_TABLE_NAME IS NULL OR TRIM(P_TABLE_NAME) = '' OR
            P_DATA_STAGING_TABLE_FQDN IS NULL OR TRIM(P_DATA_STAGING_TABLE_FQDN) = '' OR
            P_TRACKING_STAGING_TABLE_FQDN IS NULL OR TRIM(P_TRACKING_STAGING_TABLE_FQDN) = '' OR
            P_RUN_UUID IS NULL OR TRIM(P_RUN_UUID) = '') THEN

            lv_status := 'FAILED_INPUT';
            lv_message := 'ERROR: Invalid input for SP_COLLECT_DYNAMIC_TABLE_METADATA. Missing required parameters.';
            RAISE E_INPUT_VALIDATION_FAILED; -- Use declared exception
        END IF;

        lv_func_args := 'NAME => ''' || :lv_qualified_name_to_filter || '''';

        EXECUTE IMMEDIATE '
            INSERT INTO IDENTIFIER(?) (
                COLLECTION_TIMESTAMP, DATABASE_NAME, SCHEMA_NAME, TABLE_NAME, QUALIFIED_NAME,
                TARGET_LAG_SEC, TARGET_LAG_TYPE,
                SCHEDULING_STATE_STATUS, SCHEDULING_STATE_REASON_CODE, SCHEDULING_STATE_REASON_MESSAGE,
                SCHEDULING_STATE_SUSPENDED_ON, SCHEDULING_STATE_RESUMED_ON,
                MEAN_LAG_SEC, MAXIMUM_LAG_SEC, TIME_ABOVE_TARGET_LAG_SEC, TIME_WITHIN_TARGET_LAG_RATIO,
                LATEST_DATA_TIMESTAMP, LAST_COMPLETED_REFRESH_STATE, LAST_COMPLETED_REFRESH_STATE_CODE,
                LAST_COMPLETED_REFRESH_STATE_MESSAGE, EXECUTING_REFRESH_QUERY_ID
            )
            SELECT
                CURRENT_TIMESTAMP()::TIMESTAMP_NTZ AS COLLECTION_TIMESTAMP_SOURCE,
                dt.DATABASE_NAME, dt.SCHEMA_NAME, dt.NAME AS TABLE_NAME, dt.QUALIFIED_NAME,
                dt.TARGET_LAG_SEC, dt.TARGET_LAG_TYPE,
                dt.SCHEDULING_STATE:STATE::TEXT,
                dt.SCHEDULING_STATE:REASON_CODE::TEXT,
                dt.SCHEDULING_STATE:REASON_MESSAGE::TEXT,
                dt.SCHEDULING_STATE:SUSPENDED_ON::TIMESTAMP_NTZ,
                dt.SCHEDULING_STATE:RESUMED_ON::TIMESTAMP_NTZ,
                dt.MEAN_LAG_SEC, dt.MAXIMUM_LAG_SEC, dt.TIME_ABOVE_TARGET_LAG_SEC, dt.TIME_WITHIN_TARGET_LAG_RATIO,
                dtrh.LATEST_DATA_TIMESTAMP::TIMESTAMP_NTZ,
                dtrh.LAST_COMPLETED_REFRESH_STATE,
                dtrh.LAST_COMPLETED_REFRESH_STATE_CODE,
                dtrh.LAST_COMPLETED_REFRESH_STATE_MESSAGE,
                dtrh.EXECUTING_REFRESH_QUERY_ID
            FROM
                TABLE(INFORMATION_SCHEMA.DYNAMIC_TABLES(' || lv_func_args || ')) dtrh
            WHERE dtrh.QUALIFIED_NAME = ''' || :lv_qualified_name_to_filter || '''
        ' USING P_DATA_STAGING_TABLE_FQDN;

        lv_records_fetched := ROW_COUNT();
        lv_message := 'Successfully collected ' || lv_records_fetched || ' records into metadata staging.';
        lv_status := 'SUCCESS';

    EXCEPTION
        WHEN E_INPUT_VALIDATION_FAILED THEN -- Catch the specific exception
            -- Message already set above
            lv_status := 'FAILED_INPUT';
        WHEN OTHER THEN
            lv_message := 'Error collecting metadata for ' || lv_qualified_name_to_filter || ': ' || SQLERRM();
            lv_status := 'FAILED_EXECUTION';
            -- No need to RAISE again, just handle it and fall through to the final insert
    END;

    -- Insert status directly into the tracking staging table (always executed)
    EXECUTE IMMEDIATE '
        INSERT INTO IDENTIFIER(?) (
            QUALIFIED_NAME,
            JOB_TYPE,
            STATUS,
            MESSAGE,
            COLLECTION_TIMESTAMP,
            DRIVER_RUN_UUID
        ) VALUES (?, ?, ?, ?, ?);
    ' USING P_TRACKING_STAGING_TABLE_FQDN, lv_qualified_name_to_filter, 'METADATA_SNAPSHOT', lv_status, lv_message, lv_collection_current_time, P_RUN_UUID;

    RETURN lv_status;
$$;
