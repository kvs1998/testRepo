CREATE OR REPLACE PROCEDURE YOUR_DB.YOUR_SCHEMA.SP_COLLECT_DT_REFRESH_HISTORY(
    P_DATABASE_NAME VARCHAR,
    P_SCHEMA_NAME VARCHAR,
    P_TABLE_NAME VARCHAR,
    P_COLLECT_FROM_LAST_DAYS NUMBER,
    P_DATA_STAGING_TABLE_FQDN VARCHAR,
    P_TRACKING_STAGING_TABLE_FQDN VARCHAR,
    P_RUN_UUID VARCHAR
)
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS
$$
DECLARE
    lv_func_args VARCHAR := '';
    lv_records_fetched INTEGER;
    lv_qualified_name_to_filter VARCHAR;
    lv_collection_current_time TIMESTAMP_LTZ := CURRENT_TIMESTAMP();

    lv_status VARCHAR;
    lv_message VARCHAR;

    LV_MAX_INFO_SCHEMA_DAYS NUMBER := 7;
    lv_actual_days_to_collect NUMBER;

    -- NEW: Declare custom exceptions
    E_INPUT_VALIDATION_FAILED EXCEPTION (-20001, 'Input Validation Failed for Refresh History Collection');
    E_COLLECTION_EXECUTION_FAILED EXCEPTION (-20002, 'Data Collection Execution Failed for Refresh History');

BEGIN
    lv_qualified_name_to_filter := :P_DATABASE_NAME || '.' || :P_SCHEMA_NAME || '.' || :P_TABLE_NAME;
    lv_status := 'SUCCESS';
    lv_message := 'Successfully collected data into staging.';

    BEGIN -- Inner block for data collection specific errors
        IF (P_DATABASE_NAME IS NULL OR TRIM(P_DATABASE_NAME) = '' OR
            P_SCHEMA_NAME IS NULL OR TRIM(P_SCHEMA_NAME) = '' OR
            P_TABLE_NAME IS NULL OR TRIM(P_TABLE_NAME) = '' OR
            P_COLLECT_FROM_LAST_DAYS IS NULL OR P_COLLECT_FROM_LAST_DAYS <= 0 OR
            P_DATA_STAGING_TABLE_FQDN IS NULL OR TRIM(P_DATA_STAGING_TABLE_FQDN) = '' OR
            P_TRACKING_STAGING_TABLE_FQDN IS NULL OR TRIM(P_TRACKING_STAGING_TABLE_FQDN) = '' OR
            P_RUN_UUID IS NULL OR TRIM(P_RUN_UUID) = '') THEN

            lv_status := 'FAILED_INPUT';
            lv_message := 'ERROR: Invalid input for SP_COLLECT_DT_REFRESH_HISTORY. Missing required parameters.';
            RAISE E_INPUT_VALIDATION_FAILED; -- Use declared exception
        END IF;

        lv_actual_days_to_collect := LEAST(P_COLLECT_FROM_LAST_DAYS, LV_MAX_INFO_SCHEMA_DAYS);

        lv_func_args := '
            NAME => ''' || :P_DATABASE_NAME || '.' || :P_SCHEMA_NAME || '.' || :P_TABLE_NAME || ''',
            END_TIME_RANGE_START => DATEADD(day, -' || :lv_actual_days_to_collect || ', ''' || lv_collection_current_time || '''::TIMESTAMP_LTZ),
            END_TIME_RANGE_END => ''' || lv_collection_current_time || '''::TIMESTAMP_LTZ
        ';

        EXECUTE IMMEDIATE '
            INSERT INTO IDENTIFIER(?) (
                DATABASE_NAME, SCHEMA_NAME, TABLE_NAME, QUALIFIED_NAME,
                STATE, STATE_CODE, STATE_MESSAGE, QUERY_ID, DATA_TIMESTAMP,
                REFRESH_START_TIME, REFRESH_END_TIME, COMPLETION_TARGET,
                LAST_COMPLETED_DEPENDENCY_QUALIFIED_NAME, LAST_COMPLETED_DEPENDENCY_DATA_TIMESTAMP,
                NUMINSERTEDROWS, NUMDELETEDROWS, NUMCOPIEDROWS, NUMADDEDPARTITIONS, NUMREMOVEDPARTITIONS,
                REFRESH_ACTION, REFRESH_TRIGGER, TARGET_LAG_SEC, GRAPH_HISTORY_VALID_FROM
            )
            SELECT
                drh.DATABASE_NAME, drh.SCHEMA_NAME, drh.TABLE_NAME, drh.QUALIFIED_NAME,
                drh.STATE, drh.STATE_CODE, drh.STATE_MESSAGE, drh.QUERY_ID, drh.DATA_TIMESTAMP,
                drh.REFRESH_START_TIME, drh.REFRESH_END_TIME, drh.COMPLETION_TARGET,
                drh.LAST_COMPLETED_DEPENDENCY:QUALIFIED_NAME::TEXT,
                drh.LAST_COMPLETED_DEPENDENCY:DATA_TIMESTAMP::TIMESTAMP_LTZ,
                drh.STATISTICS:NUMINSERTEDROWS::NUMBER, drh.STATISTICS:NUMDELETEDROWS::NUMBER,
                drh.STATISTICS:NUMCOPIEDROWS::NUMBER, drh.STATISTICS:NUMADDEDPARTITIONS::NUMBER,
                drh.STATISTICS:NUMREMOVEDPARTITIONS::NUMBER, drh.REFRESH_ACTION,
                drh.REFRESH_TRIGGER, drh.TARGET_LAG_SEC, drh.GRAPH_HISTORY_VALID_FROM
            FROM
                TABLE(INFORMATION_SCHEMA.DYNAMIC_TABLE_REFRESH_HISTORY(' || lv_func_args || ')) drh
            WHERE drh.QUALIFIED_NAME = ''' || :lv_qualified_name_to_filter || '''
        ' USING P_DATA_STAGING_TABLE_FQDN;

        lv_records_fetched := ROW_COUNT();
        lv_message := 'Successfully collected ' || lv_records_fetched || ' records into history staging.';
        lv_status := 'SUCCESS';

    EXCEPTION
        WHEN E_INPUT_VALIDATION_FAILED THEN -- Catch the specific exception
            -- Message already set above
            lv_status := 'FAILED_INPUT';
        WHEN OTHER THEN
            lv_message := 'Error collecting history for ' || lv_qualified_name_to_filter || ': ' || SQLERRM();
            lv_status := 'FAILED_EXECUTION';
            -- No need to RAISE again, just handle it and fall through to the final insert
    END;

    -- Insert status directly into the tracking staging table (always executed)
    EXECUTE IMMEDIATE '
        INSERT INTO IDENTIFIER(?) (
            QUALIFIED_NAME,
            JOB_TYPE,
            STATUS,
            MESSAGE,
            COLLECTION_TIMESTAMP,
            DRIVER_RUN_UUID
        ) VALUES (?, ?, ?, ?, ?);
    ' USING P_TRACKING_STAGING_TABLE_FQDN, lv_qualified_name_to_filter, 'REFRESH_HISTORY', lv_status, lv_message, lv_collection_current_time, P_RUN_UUID;

    RETURN lv_status;
$$;
