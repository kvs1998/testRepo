CREATE OR REPLACE PROCEDURE YOUR_DB.YOUR_SCHEMA.SP_DRIVE_ALL_DT_COLLECTION()
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS
$$
DECLARE
    -- --- Configuration Variables ---
    LV_TRACKING_TABLE_FQDN VARCHAR := 'YOUR_DB.YOUR_SCHEMA.T_DYNAMIC_TABLE_TRACKING';
    LV_REFRESH_HISTORY_PROC_FQDN VARCHAR := 'YOUR_DB.YOUR_SCHEMA.SP_COLLECT_DT_REFRESH_HISTORY';
    LV_METADATA_PROC_FQDN VARCHAR := 'YOUR_DB.YOUR_SCHEMA.SP_COLLECT_DYNAMIC_TABLE_METADATA';
    
    -- --- Internal Variables ---
    lv_message VARCHAR DEFAULT '';
    lv_total_tables_found INTEGER DEFAULT 0;
    lv_jobs_launched_count INTEGER DEFAULT 0;
    lv_overall_success_count INTEGER DEFAULT 0;
    lv_overall_fail_count INTEGER DEFAULT 0;
    lv_db_name VARCHAR;
    lv_schema_name VARCHAR;
    lv_table_name VARCHAR;
    lv_qualified_name VARCHAR;
    lv_track_refresh_history BOOLEAN;
    lv_track_metadata_snapshot BOOLEAN;
    lv_track_graph_history BOOLEAN; -- Not implemented yet, but included in schema
    lv_refresh_history_days NUMBER;
    lv_metadata_days NUMBER;
    lv_loop_error_message VARCHAR; -- For errors during ASYNC job SUBMISSION
    lv_error_message_overall VARCHAR; -- For major errors outside loop

    -- --- NEW: Variables for precise start/end time of this driver run ---
    lv_driver_run_start_time TIMESTAMP_LTZ;
    lv_driver_run_end_time TIMESTAMP_LTZ;

    -- Cursor to select active tables needing collection
    c_tables CURSOR FOR
        SELECT 
            DATABASE_NAME, SCHEMA_NAME, TABLE_NAME, QUALIFIED_NAME,
            TRACK_REFRESH_HISTORY, TRACK_METADATA_SNAPSHOT, TRACK_GRAPH_HISTORY,
            COLLECT_REFRESH_HISTORY_DAYS, COLLECT_METADATA_DAYS
        FROM IDENTIFIER(:LV_TRACKING_TABLE_FQDN)
        WHERE IS_ACTIVE = TRUE;

BEGIN
    -- Capture the exact start time of this driver run
    lv_driver_run_start_time := CURRENT_TIMESTAMP();
    lv_message := lv_message || 'Starting DYNAMIC TABLE COLLECTION DRIVER at ' || lv_driver_run_start_time || '\n';
    
    -- --- Step 1: Launch all ASYNC jobs ---
    OPEN c_tables;
    LOOP
        FETCH c_tables INTO lv_db_name, lv_schema_name, lv_table_name, lv_qualified_name,
                             lv_track_refresh_history, lv_track_metadata_snapshot, lv_track_graph_history,
                             lv_refresh_history_days, lv_metadata_days;
        IF (c_tables%NOTFOUND) THEN
            BREAK; -- Exit loop when no more records
        END IF;

        lv_total_tables_found := lv_total_tables_found + 1;

        BEGIN -- Inner BEGIN/END block for per-table ASYNC job submission error handling
            
            lv_message := lv_message || '  Submitting jobs for table: ' || lv_qualified_name || '\n';

            -- Launch SP_COLLECT_DT_REFRESH_HISTORY ASYNC
            -- This sub-procedure *must* be modified to update T_DYNAMIC_TABLE_TRACKING itself
            IF (lv_track_refresh_history) THEN
                ASYNC ( -- Correct ASYNC syntax
                    EXECUTE IMMEDIATE 'CALL ' || :LV_REFRESH_HISTORY_PROC_FQDN || '(?, ?, ?, ?)'
                    USING lv_db_name, lv_schema_name, lv_table_name, lv_refresh_history_days
                );
                lv_jobs_launched_count := lv_jobs_launched_count + 1;
                lv_message := lv_message || '    Refresh History job submitted ASYNC.\n';
            END IF;

            -- Launch SP_COLLECT_DYNAMIC_TABLE_METADATA ASYNC
            -- This sub-procedure *must* be modified to update T_DYNAMIC_TABLE_TRACKING itself
            IF (lv_track_metadata_snapshot) THEN
                ASYNC ( -- Correct ASYNC syntax
                    EXECUTE IMMEDIATE 'CALL ' || :LV_METADATA_PROC_FQDN || '(?, ?, ?)'
                    USING lv_db_name, lv_schema_name, lv_table_name
                );
                lv_jobs_launched_count := lv_jobs_launched_count + 1;
                lv_message := lv_message || '    Metadata Snapshot job submitted ASYNC.\n';
            END IF;

            -- Add logic for TRACK_GRAPH_HISTORY if you implement that procedure later
            -- This sub-procedure *must* also update T_DYNAMIC_TABLE_TRACKING itself
            -- IF (lv_track_graph_history) THEN
            --    ASYNC (EXECUTE IMMEDIATE 'CALL ' || :LV_GRAPH_HISTORY_PROC_FQDN || '(?)' USING lv_qualified_name);
            --    lv_jobs_launched_count := lv_jobs_launched_count + 1;
            --    lv_message := lv_message || '    Graph History job submitted ASYNC.\n';
            -- END IF;

        EXCEPTION
            WHEN OTHER THEN
                lv_loop_error_message := 'ERROR submitting ASYNC job(s) for ' || lv_qualified_name || ': ' || SQLERRM();
                lv_message := lv_message || '    ' || lv_loop_error_message || '\n';
                -- If submission fails, it's implicitly a 'failed to start' for this table
        END; -- End inner BEGIN/END block for submission
    END LOOP;
    CLOSE c_tables;

    lv_message := lv_message || 'All ASYNC jobs launched (' || lv_jobs_launched_count || ' jobs). Awaiting all completion...\n';

    -- --- Step 2: AWAIT ALL submitted ASYNC jobs ---
    -- This single statement will block until all ASYNC jobs initiated in this session are done.
    AWAIT ALL; 
    
    -- Capture the exact end time of this driver run
    lv_driver_run_end_time := CURRENT_TIMESTAMP();
    lv_message := lv_message || 'All ASYNC jobs completed. Collecting summary from tracking table...\n';

    -- --- Step 3: Final Summary from T_DYNAMIC_TABLE_TRACKING ---
    -- Count successes for jobs whose collection timestamp falls within THIS driver run's window
    SELECT 
        COUNT(CASE WHEN LAST_REFRESH_HISTORY_COLLECTION_STATUS = 'SUCCESS' 
                   AND LAST_REFRESH_HISTORY_COLLECTION_TIMESTAMP BETWEEN :lv_driver_run_start_time AND :lv_driver_run_end_time THEN 1 END) +
        COUNT(CASE WHEN LAST_METADATA_COLLECTION_STATUS = 'SUCCESS' 
                   AND LAST_METADATA_COLLECTION_TIMESTAMP BETWEEN :lv_driver_run_start_time AND :lv_driver_run_end_time THEN 1 END)
    INTO lv_overall_success_count
    FROM IDENTIFIER(:LV_TRACKING_TABLE_FQDN);

    -- Count failures for jobs whose collection timestamp falls within THIS driver run's window
    SELECT 
        COUNT(CASE WHEN LAST_REFRESH_HISTORY_COLLECTION_STATUS = 'FAILED' 
                   AND LAST_REFRESH_HISTORY_COLLECTION_TIMESTAMP BETWEEN :lv_driver_run_start_time AND :lv_driver_run_end_time THEN 1 END) +
        COUNT(CASE WHEN LAST_METADATA_COLLECTION_STATUS = 'FAILED' 
                   AND LAST_METADATA_COLLECTION_TIMESTAMP BETWEEN :lv_driver_run_start_time AND :lv_driver_run_end_time THEN 1 END)
    INTO lv_overall_fail_count
    FROM IDENTIFIER(:LV_TRACKING_TABLE_FQDN);

    lv_message := lv_message || 'DYNAMIC TABLE COLLECTION DRIVER finished at ' || lv_driver_run_end_time || '\n';
    lv_message := lv_message || 'Total tables in tracking: ' || lv_total_tables_found || '\n';
    lv_message := lv_message || 'Total ASYNC Jobs launched: ' || lv_jobs_launched_count || '\n';
    lv_message := lv_message || 'Overall Success for this run: ' || lv_overall_success_count || '\n';
    lv_message := lv_message || 'Overall Failed for this run: ' || lv_overall_fail_count || '\n';
    
    RETURN lv_message;

EXCEPTION
    WHEN OTHER THEN
        lv_error_message_overall := 'Major Error in DYNAMIC TABLE COLLECTION DRIVER: ' || SQLERRM();
        RETURN lv_error_message_overall;
END;
$$;
