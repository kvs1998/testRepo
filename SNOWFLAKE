CREATE OR REPLACE PROCEDURE YOUR_DB.YOUR_SCHEMA.SP_DRIVE_ALL_DT_COLLECTION()
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS
$$
DECLARE
    -- --- Configuration Variables ---
    LV_TRACKING_TABLE_FQDN VARCHAR := 'YOUR_DB.YOUR_SCHEMA.T_DYNAMIC_TABLE_TRACKING';
    LV_REFRESH_HISTORY_PROC_FQDN VARCHAR := 'YOUR_DB.YOUR_SCHEMA.SP_COLLECT_DT_REFRESH_HISTORY';
    LV_METADATA_PROC_FQDN VARCHAR := 'YOUR_DB.YOUR_SCHEMA.SP_COLLECT_DYNAMIC_TABLE_METADATA';
    -- LV_GRAPH_HISTORY_PROC_FQDN VARCHAR := 'YOUR_DB.YOUR_SCHEMA.SP_COLLECT_DT_GRAPH_HISTORY'; -- Placeholder
    
    -- --- Internal Variables ---
    lv_message VARCHAR DEFAULT '';
    lv_total_tables_found INTEGER DEFAULT 0;
    lv_jobs_launched_count INTEGER DEFAULT 0;
    lv_current_table_qualified_name VARCHAR; 
    lv_refresh_history_days NUMBER;
    lv_metadata_days NUMBER;
    lv_loop_error_message VARCHAR; -- For errors during ASYNC job SUBMISSION
    lv_error_message_overall VARCHAR; -- For major errors outside loop

    -- Cursor to select active tables needing collection
    c_tables CURSOR FOR
        SELECT 
            DATABASE_NAME, SCHEMA_NAME, TABLE_NAME, QUALIFIED_NAME,
            TRACK_REFRESH_HISTORY, TRACK_METADATA_SNAPSHOT, TRACK_GRAPH_HISTORY,
            COLLECT_REFRESH_HISTORY_DAYS, COLLECT_METADATA_DAYS
        FROM IDENTIFIER(:LV_TRACKING_TABLE_FQDN)
        WHERE IS_ACTIVE = TRUE;

BEGIN
    lv_message := lv_message || 'Starting DYNAMIC TABLE COLLECTION DRIVER at ' || CURRENT_TIMESTAMP() || '\n';
    
    -- --- Step 1: Launch all ASYNC jobs ---
    OPEN c_tables;
    LOOP
        FETCH c_tables INTO lv_db_name, lv_schema_name, lv_table_name, lv_current_table_qualified_name,
                             lv_track_refresh_history, lv_track_metadata_snapshot, lv_track_graph_history,
                             lv_refresh_history_days, lv_metadata_days;
        IF (c_tables%NOTFOUND) THEN
            BREAK; -- Exit loop when no more records
        END IF;

        lv_total_tables_found := lv_total_tables_found + 1;

        BEGIN -- Inner BEGIN/END block for per-table ASYNC job submission error handling
            
            lv_message := lv_message || '  Submitting jobs for table: ' || lv_current_table_qualified_name || '\n';

            -- Launch SP_COLLECT_DT_REFRESH_HISTORY ASYNC
            -- This sub-procedure *must* be modified to update T_DYNAMIC_TABLE_TRACKING itself
            IF (lv_track_refresh_history) THEN
                ASYNC ( -- Correct ASYNC syntax
                    EXECUTE IMMEDIATE 'CALL ' || :LV_REFRESH_HISTORY_PROC_FQDN || '(?, ?, ?, ?)'
                    USING lv_db_name, lv_schema_name, lv_table_name, lv_refresh_history_days
                );
                lv_jobs_launched_count := lv_jobs_launched_count + 1;
                lv_message := lv_message || '    Refresh History job submitted ASYNC.\n';
            END IF;

            -- Launch SP_COLLECT_DYNAMIC_TABLE_METADATA ASYNC
            -- This sub-procedure *must* be modified to update T_DYNAMIC_TABLE_TRACKING itself
            IF (lv_track_metadata_snapshot) THEN
                ASYNC ( -- Correct ASYNC syntax
                    EXECUTE IMMEDIATE 'CALL ' || :LV_METADATA_PROC_FQDN || '(?, ?, ?)'
                    USING lv_db_name, lv_schema_name, lv_table_name
                );
                lv_jobs_launched_count := lv_jobs_launched_count + 1;
                lv_message := lv_message || '    Metadata Snapshot job submitted ASYNC.\n';
            END IF;

            -- Add logic for TRACK_GRAPH_HISTORY if you implement that procedure later
            -- This sub-procedure *must* also update T_DYNAMIC_TABLE_TRACKING itself
            -- IF (lv_track_graph_history) THEN
            --    ASYNC (EXECUTE IMMEDIATE 'CALL ' || :LV_GRAPH_HISTORY_PROC_FQDN || '(?)' USING lv_current_table_qualified_name);
            --    lv_jobs_launched_count := lv_jobs_launched_count + 1;
            --    lv_message := lv_message || '    Graph History job submitted ASYNC.\n';
            -- END IF;

        EXCEPTION
            WHEN OTHER THEN
                lv_loop_error_message := 'ERROR submitting ASYNC job(s) for ' || lv_current_table_qualified_name || ': ' || SQLERRM();
                lv_message := lv_message || '    ' || lv_loop_error_message || '\n';
                -- Submission failure for a table doesn't halt the driver.
                -- The tracking table for this specific table/job won't be updated by child SP,
                -- which is an implicit 'failed to start' status.
        END; -- End inner BEGIN/END block for submission
    END LOOP;
    CLOSE c_tables;

    lv_message := lv_message || 'All ASYNC jobs launched (' || lv_jobs_launched_count || ' jobs). Awaiting all completion...\n';

    -- --- Step 2: AWAIT ALL submitted ASYNC jobs ---
    -- This single statement will block until all ASYNC jobs initiated in this session are done.
    -- The individual sub-procedures are responsible for updating the tracking table with SUCCESS/FAILED.
    AWAIT ALL; 
    lv_message := lv_message || 'All ASYNC jobs completed. Individual job statuses are updated by child procedures.\n';

    -- --- Step 3: Final Summary and Return ---
    -- We can get a final count based on the tracking table's *current* state.
    -- This requires SUMMING status from T_DYNAMIC_TABLE_TRACKING AFTER all jobs (and their updates) are done.
    
    SELECT 
        COUNT(CASE WHEN LAST_REFRESH_HISTORY_COLLECTION_STATUS = 'SUCCESS' THEN 1 END) +
        COUNT(CASE WHEN LAST_METADATA_COLLECTION_STATUS = 'SUCCESS' THEN 1 END)
    INTO lv_overall_success_count
    FROM IDENTIFIER(:LV_TRACKING_TABLE_FQDN)
    WHERE LAST_REFRESH_HISTORY_COLLECTION_TIMESTAMP >= (CURRENT_TIMESTAMP() - INTERVAL '1 MINUTE') OR -- Only count recent completions
          LAST_METADATA_COLLECTION_TIMESTAMP >= (CURRENT_TIMESTAMP() - INTERVAL '1 MINUTE'); -- This is a heuristic, adjust interval if job runs infrequently

    SELECT 
        COUNT(CASE WHEN LAST_REFRESH_HISTORY_COLLECTION_STATUS = 'FAILED' THEN 1 END) +
        COUNT(CASE WHEN LAST_METADATA_COLLECTION_STATUS = 'FAILED' THEN 1 END)
    INTO lv_overall_fail_count
    FROM IDENTIFIER(:LV_TRACKING_TABLE_FQDN)
    WHERE LAST_REFRESH_HISTORY_COLLECTION_TIMESTAMP >= (CURRENT_TIMESTAMP() - INTERVAL '1 MINUTE') OR
          LAST_METADATA_COLLECTION_TIMESTAMP >= (CURRENT_TIMESTAMP() - INTERVAL '1 MINUTE');

    lv_message := lv_message || 'DYNAMIC TABLE COLLECTION DRIVER finished at ' || CURRENT_TIMESTAMP() || '\n';
    lv_message := lv_message || 'Total tables found in tracking: ' || lv_total_tables_found || '\n';
    lv_message := lv_message || 'Total ASYNC Jobs launched: ' || lv_jobs_launched_count || '\n';
    lv_message := lv_message || 'Recent Overall Success (from tracking table): ' || lv_overall_success_count || '\n';
    lv_message := lv_message || 'Recent Overall Failed (from tracking table): ' || lv_overall_fail_count || '\n';
    
    RETURN lv_message;

EXCEPTION
    WHEN OTHER THEN
        lv_error_message_overall := 'Major Error in DYNAMIC TABLE COLLECTION DRIVER: ' || SQLERRM();
        RETURN lv_error_message_overall;
END;
$$;
