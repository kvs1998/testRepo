# tabs/dt_health_tab.py
import streamlit as st
import pandas as pd
import plotly.express as px
import numpy as np

def render_dt_health_tab(metadata_df: pd.DataFrame):
    st.header("Dynamic Table Health & Current Status")
    st.write("Analyze the current operational state and aggregate lag metrics of your dynamic tables.")

    if metadata_df.empty:
        st.info("No metadata available for DT HEALTH tab. Check data source or collection.", icon="ℹ️")
        return

    # --- Filters for DT Health Tab ---
    st.markdown("---")
    st.subheader("Apply Filters for DT Health")

    filter_cols_dt_health = st.columns([1, 1, 1, 1])

    with filter_cols_dt_health[0]:
        all_databases_dt_health = ['All'] + sorted(metadata_df['DATABASE_NAME'].unique().tolist())
        selected_database_dt_health = st.selectbox(
            "Database:", options=all_databases_dt_health, key="db_filter_dt_health"
        )
    with filter_cols_dt_health[1]:
        if selected_database_dt_health != 'All':
            current_db_schemas_dt_health = metadata_df[metadata_df['DATABASE_NAME'] == selected_database_dt_health]['SCHEMA_NAME'].unique().tolist()
            schemas_in_db_dt_health = ['All'] + sorted(current_db_schemas_dt_health)
        else:
            schemas_in_db_dt_health = ['All'] + sorted(metadata_df['SCHEMA_NAME'].unique().tolist())
        selected_schema_dt_health = st.selectbox(
            "Schema:", options=schemas_in_db_dt_health, key="schema_filter_dt_health"
        )
    with filter_cols_dt_health[2]:
        filtered_df_for_table_options_dt_health = metadata_df.copy()
        if selected_database_dt_health != 'All':
            filtered_df_for_table_options_dt_health = filtered_df_for_table_options_dt_health[filtered_df_for_table_options_dt_health['DATABASE_NAME'] == selected_database_dt_health]
        if selected_schema_dt_health != 'All':
            filtered_df_for_table_options_dt_health = filtered_df_for_table_options_dt_health[filtered_df_for_table_options_dt_health['SCHEMA_NAME'] == selected_schema_dt_health]

        if not filtered_df_for_table_options_dt_health.empty:
            all_tables_dt_health_options = ['All'] + sorted(filtered_df_for_table_options_dt_health['TABLE_NAME'].unique().tolist())
            default_tables_dt_health_selected = ['All']
        else:
            all_tables_dt_health_options = ['All']
            default_tables_dt_health_selected = ['All']
            st.info("No tables found for selected DB/Schema.", icon="ℹ️")
        selected_table_dt_health = st.multiselect(
            "Table(s):", options=all_tables_dt_health_options, default=default_tables_dt_health_selected, key="table_filter_dt_health"
        )
    with filter_cols_dt_health[3]:
        all_scheduling_states = ['All'] + sorted(metadata_df['SCHEDULING_STATE_STATUS'].unique().tolist())
        selected_scheduling_state = st.multiselect(
            "Scheduling State(s):", options=all_scheduling_states, default=['All'], key="scheduling_state_filter_dt_health"
        )
    
    # --- Apply Filters ---
    filtered_metadata_df = metadata_df.copy()

    if selected_database_dt_health != 'All':
        filtered_metadata_df = filtered_metadata_df[filtered_metadata_df['DATABASE_NAME'] == selected_database_dt_health]
    if selected_schema_dt_health != 'All':
        filtered_metadata_df = filtered_metadata_df[filtered_metadata_df['SCHEMA_NAME'] == selected_schema_dt_health]
    if selected_table_dt_health and 'All' not in selected_table_dt_health:
        filtered_metadata_df = filtered_metadata_df[filtered_metadata_df['TABLE_NAME'].isin(selected_table_dt_health)]
    elif not selected_table_dt_health:
        st.warning("No table(s) selected. Display will be empty.", icon="⚠️")
        filtered_metadata_df = pd.DataFrame()

    if selected_scheduling_state and 'All' not in selected_scheduling_state:
        filtered_metadata_df = filtered_metadata_df[filtered_metadata_df['SCHEDULING_STATE_STATUS'].isin(selected_scheduling_state)]
    elif not selected_scheduling_state:
        st.warning("No scheduling state(s) selected. Display will be empty.", icon="⚠️")
        filtered_metadata_df = pd.DataFrame()

    st.markdown("---")

    if filtered_metadata_df.empty:
        st.info("No data available based on current filter selections. Please adjust your filters.", icon="ℹ️")
        return # Exit if no data after filtering


    # --- KPIs for DT Health Tab ---
    st.subheader("Current Dynamic Table Health KPIs")
    
    total_dt_monitored = filtered_metadata_df['QUALIFIED_NAME'].nunique()
    running_dt_count = filtered_metadata_df[filtered_metadata_df['SCHEDULING_STATE_STATUS'] == 'RUNNING']['QUALIFIED_NAME'].nunique()
    suspended_dt_count = filtered_metadata_df[filtered_metadata_df['SCHEDULING_STATE_STATUS'] == 'SUSPENDED']['QUALIFIED_NAME'].nunique()
    executing_refresh_dt_count = filtered_metadata_df[filtered_metadata_df['EXECUTING_REFRESH_QUERY_ID'].notna()]['QUALIFIED_NAME'].nunique()
    
    avg_mean_lag = filtered_metadata_df['MEAN_LAG_SEC'].mean()
    max_lag = filtered_metadata_df['MAXIMUM_LAG_SEC'].max()

    kpi_cols_dt_health = st.columns(3)
    with kpi_cols_dt_health[0]:
        st.markdown(f"<p style='font-size:14px; margin-bottom:0;'>Total DTs Monitored</p>", unsafe_allow_html=True)
        st.markdown(f"<h3 style='margin-top:0;'>{total_dt_monitored}</h3>", unsafe_allow_html=True)
    with kpi_cols_dt_health[1]:
        st.markdown(f"<p style='font-size:14px; color:green; margin-bottom:0;'>Running DTs</p>", unsafe_allow_html=True)
        st.markdown(f"<h3 style='margin-top:0;'>{running_dt_count}</h3>", unsafe_allow_html=True)
    with kpi_cols_dt_health[2]:
        st.markdown(f"<p style='font-size:14px; color:red; margin-bottom:0;'>Suspended DTs</p>", unsafe_allow_html=True)
        st.markdown(f"<h3 style='margin-top:0;'>{suspended_dt_count}</h3>", unsafe_allow_html=True)
    
    kpi_cols_dt_health_row2 = st.columns(3)
    with kpi_cols_dt_health_row2[0]:
        st.markdown(f"<p style='font-size:14px; color:blue; margin-bottom:0;'>Refreshing Now</p>", unsafe_allow_html=True)
        st.markdown(f"<h3 style='margin-top:0;'>{executing_refresh_dt_count} tables</h3>", unsafe_allow_html=True)
    with kpi_cols_dt_health_row2[1]:
        st.markdown(f"<p style='font-size:14px; margin-bottom:0;'>Avg Mean Lag (s)</p>", unsafe_allow_html=True)
        st.markdown(f"<h3 style='margin-top:0;'>{avg_mean_lag:.1f}</h3>", unsafe_allow_html=True)
    with kpi_cols_dt_health_row2[2]:
        st.markdown(f"<p style='font-size:14px; margin-bottom:0;'>Max Lag (s)</p>", unsafe_allow_html=True)
        st.markdown(f"<h3 style='margin-top:0;'>{max_lag:.1f}</h3>", unsafe_allow_html=True)
        
    st.divider()

    # --- Scheduling State Distribution Chart ---
    st.subheader("Dynamic Table Scheduling State Distribution")
    st.write("Current distribution of dynamic tables by their scheduling status (RUNNING vs. SUSPENDED).")
    
    scheduling_state_counts = filtered_metadata_df['SCHEDULING_STATE_STATUS'].value_counts().reset_index()
    scheduling_state_counts.columns = ['Status', 'Count']
    
    fig_scheduling_state = px.pie(scheduling_state_counts, 
                                  values='Count', 
                                  names='Status', 
                                  title='Scheduling State Distribution',
                                  hole=0.3,
                                  color_discrete_map={'RUNNING': 'green', 'SUSPENDED': 'red'})
    fig_scheduling_state.update_traces(textposition='inside', textinfo='percent+label')
    st.plotly_chart(fig_scheduling_state, use_container_width=True)

    st.divider()

    # --- Top N Tables by Time Above Target Lag ---
    st.subheader("Tables Most Frequently Above Target Lag")
    st.write("Top dynamic tables by the total time (in seconds) they have spent above their target lag.")

    # Filter to tables that actually have a TIME_ABOVE_TARGET_LAG_SEC > 0 for this chart
    above_target_lag_df = filtered_metadata_df[
        filtered_metadata_df['TIME_ABOVE_TARGET_LAG_SEC'] > 0
    ].sort_values('TIME_ABOVE_TARGET_LAG_SEC', ascending=False)
    
    if not above_target_lag_df.empty:
        num_top_lag_tables = st.slider(
            "Show Top N Tables by Time Above Target Lag:",
            min_value=5, max_value=min(20, len(above_target_lag_df)), value=min(10, len(above_target_lag_df)),
            key="top_lag_tables_slider_dt_health"
        )
        display_lag_tables_df = above_target_lag_df.head(num_top_lag_tables)

        fig_lag_tables = px.bar(
            display_lag_tables_df,
            x='TIME_ABOVE_TARGET_LAG_SEC',
            y='QUALIFIED_NAME',
            orientation='h',
            title=f'Top {num_top_lag_tables} Tables by Time Above Target Lag (seconds)',
            labels={'TIME_ABOVE_TARGET_LAG_SEC': 'Time Above Lag (s)', 'QUALIFIED_NAME': 'Dynamic Table'}
        )
        fig_lag_tables.update_yaxes(categoryorder='total ascending')
        st.plotly_chart(fig_lag_tables, use_container_width=True)
    else:
        st.info("No tables found with time above target lag in the current selection.", icon="ℹ️")

    st.divider()

    # --- Detailed Dynamic Table Current Status Table ---
    st.subheader("Dynamic Table Current Status Details")
    st.write("Detailed metadata and lag metrics for each dynamic table based on latest snapshot.")

    dt_health_display_columns = [
        'QUALIFIED_NAME', 'SCHEDULING_STATE_STATUS', 'SCHEDULING_STATE_REASON_MESSAGE', 
        'TARGET_LAG_SEC', 'MEAN_LAG_SEC', 'MAXIMUM_LAG_SEC', 
        'TIME_ABOVE_TARGET_LAG_SEC', 'TIME_WITHIN_TARGET_LAG_RATIO', 
        'LATEST_DATA_TIMESTAMP', 'LAST_COMPLETED_REFRESH_STATE', 'EXECUTING_REFRESH_QUERY_ID',
        'COLLECTION_TIMESTAMP' # To show when this snapshot was collected
    ]
    
    # Rename for display in the table header if needed
    dt_health_display_labels = {
        'QUALIFIED_NAME': 'Dynamic Table',
        'SCHEDULING_STATE_STATUS': 'Status',
        'SCHEDULING_STATE_REASON_MESSAGE': 'Reason',
        'TARGET_LAG_SEC': 'Target Lag (s)',
        'MEAN_LAG_SEC': 'Mean Lag (s)',
        'MAXIMUM_LAG_SEC': 'Max Lag (s)',
        'TIME_ABOVE_TARGET_LAG_SEC': 'Time Above Lag (s)',
        'TIME_WITHIN_TARGET_LAG_RATIO': 'Lag Ratio',
        'LATEST_DATA_TIMESTAMP': 'Latest Data Time',
        'LAST_COMPLETED_REFRESH_STATE': 'Last Refresh Status',
        'EXECUTING_REFRESH_QUERY_ID': 'Executing Query ID',
        'COLLECTION_TIMESTAMP': 'Snapshot Time'
    }

    if not filtered_metadata_df.empty:
        # Convert numeric columns to appropriate display format for table if needed
        # .fillna(0) for number fields that could be NaN after filtering
        df_for_dt_health_table = filtered_metadata_df.copy()
        
        # Sort by status (suspended first), then by mean lag
        df_for_dt_health_table = df_for_dt_health_table.sort_values(
            ['SCHEDULING_STATE_STATUS', 'MEAN_LAG_SEC'], ascending=[False, False]
        )

        st.dataframe(
            df_for_dt_health_table[[col for col in dt_health_display_columns if col in df_for_dt_health_table.columns]].rename(columns=dt_health_display_labels),
            use_container_width=True
        )
    else:
        st.info("No detailed dynamic table status to display based on current filters.", icon="ℹ️")
