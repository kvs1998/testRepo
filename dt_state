# tabs/dt_state_tab.py
import streamlit as st
import pandas as pd
import plotly.express as px
import numpy as np

# Assuming format_seconds_to_readable is in your utils or is a standalone helper
# For this example, I'll put it here temporarily. In a real app, you might centralize helpers.
def format_seconds_to_readable(seconds_series, format_type):
    if format_type == "seconds":
        return seconds_series.round(1).astype(str) + "s"
    elif format_type == "minutes":
        return (seconds_series / 60).round(1).astype(str) + "m"
    elif format_type == "hours":
        return (seconds_series / 3600).round(1).astype(str) + "h"
    elif format_type == "days":
        return (seconds_series / 86400).round(1).astype(str) + "d"
    elif format_type == "mixed":
        def mix_format(s):
            if pd.isna(s) or s is None: return "N/A"
            s = float(s)
            if s == 0: return "0s"

            days = int(s // 86400)
            hours = int((s % 86400) // 3600)
            minutes = int((s % 3600) // 60)
            seconds = s % 60

            parts = []
            if days > 0: parts.append(f"{days}d")
            if hours > 0: parts.append(f"{hours}h")
            if minutes > 0: parts.append(f"{minutes}m")
            if seconds > 0 and (not parts or seconds >= 1):
                parts.append(f"{seconds:.1f}s")

            return " ".join(parts) if parts else "0s"
        return seconds_series.apply(mix_format)
    return seconds_series


def render_dt_state_tab(history_df: pd.DataFrame):
    st.header("Dynamic Table Refresh State & History")
    st.write("Analyze the refresh patterns, durations, and outcomes of your dynamic tables over time.")

    if history_df.empty:
        st.info("No refresh history data available. Check data source or collection.", icon="‚ÑπÔ∏è")
        return

    # --- Data Preprocessing (if not already done in get_dt_refresh_history) ---
    # Ensure datetime columns are proper datetime objects
    for col in ['REFRESH_START_TIME', 'REFRESH_END_TIME', 'DATA_TIMESTAMP']:
        if col in history_df.columns:
            # Convert to datetime, coerce errors to NaT (Not a Time)
            history_df[f'{col}_DT'] = pd.to_datetime(history_df[col], errors='coerce')

    # Calculate Refresh Duration in Seconds
    if 'REFRESH_START_TIME_DT' in history_df.columns and 'REFRESH_END_TIME_DT' in history_df.columns:
        history_df['REFRESH_DURATION_SEC'] = (
            history_df['REFRESH_END_TIME_DT'] - history_df['REFRESH_START_TIME_DT']
        ).dt.total_seconds().fillna(0) # Fill NaNs (for running refreshes) with 0 or a placeholder


    # --- Filters for DT State Tab ---
    st.markdown("---")
    st.subheader("Apply Filters for Refresh History")

    filter_cols_dt_state_row1 = st.columns([1, 1, 1, 1])

    with filter_cols_dt_state_row1[0]:
        all_databases_dt_state = ['All'] + sorted(history_df['DATABASE_NAME'].unique().tolist())
        selected_database_dt_state = st.selectbox(
            "Database:", options=all_databases_dt_state, key="db_filter_dt_state"
        )
    with filter_cols_dt_state_row1[1]:
        temp_df_for_schema_options = history_df.copy()
        if selected_database_dt_state != 'All':
            temp_df_for_schema_options = temp_df_for_schema_options[temp_df_for_schema_options['DATABASE_NAME'] == selected_database_dt_state]

        if not temp_df_for_schema_options.empty:
            schemas_in_db_dt_state = ['All'] + sorted(temp_df_for_schema_options['SCHEMA_NAME'].unique().tolist())
        else:
            schemas_in_db_dt_state = ['All']
            st.info("No schemas found for selected Database.", icon="‚ÑπÔ∏è")

        selected_schema_dt_state = st.selectbox(
            "Schema:", options=schemas_in_db_dt_state, key="schema_filter_dt_state"
        )

    df_for_table_options_state = history_df.copy()
    if selected_database_dt_state != 'All':
        df_for_table_options_state = df_for_table_options_state[df_for_table_options_state['DATABASE_NAME'] == selected_database_dt_state]
    if selected_schema_dt_state != 'All':
        df_for_table_options_state = df_for_table_options_state[df_for_table_options_state['SCHEMA_NAME'] == selected_schema_dt_state]


    with filter_cols_dt_state_row1[2]:
        if not df_for_table_options_state.empty:
            all_tables_dt_state_options = ['All'] + sorted(df_for_table_options_state['TABLE_NAME'].unique().tolist())
            default_tables_dt_state_selected = ['All']
        else:
            all_tables_dt_state_options = ['All']
            default_tables_dt_state_selected = ['All']
            st.info("No tables found for selected DB/Schema.", icon="‚ÑπÔ∏è")
        selected_table_dt_state = st.multiselect(
            "Table(s):", options=all_tables_dt_state_options, default=default_tables_dt_state_selected, key="table_filter_dt_state"
        )

    with filter_cols_dt_state_row1[3]:
        all_states = ['All'] + sorted(history_df['STATE'].unique().tolist())
        selected_state = st.multiselect(
            "Refresh State(s):", options=all_states, default=['All'], key="refresh_state_filter_dt_state"
        )

    filter_cols_dt_state_row2 = st.columns([1, 1])

    with filter_cols_dt_state_row2[0]:
        time_range = st.date_input(
            "Select Date Range for History:",
            value=(history_df['DATA_TIMESTAMP_DT'].min(), history_df['DATA_TIMESTAMP_DT'].max()),
            min_value=history_df['DATA_TIMESTAMP_DT'].min(),
            max_value=history_df['DATA_TIMESTAMP_DT'].max(),
            key="date_range_dt_state"
        )
        if len(time_range) == 2:
            start_date, end_date = time_range
        elif len(time_range) == 1:
            start_date, end_date = time_range[0], time_range[0] # Handle single date selection
        else: # Default to full range if nothing selected or error
            start_date, end_date = history_df['DATA_TIMESTAMP_DT'].min(), history_df['DATA_TIMESTAMP_DT'].max()

    with filter_cols_dt_state_row2[1]:
        time_format_option = st.radio(
            "Display Durations In:",
            options=["mixed", "seconds", "minutes", "hours", "days"],
            index=0,
            horizontal=True,
            key="duration_format_dt_state"
        )
    st.markdown("---")

    # --- Apply Filters to Main DataFrame ---
    filtered_history_df = history_df.copy()

    if selected_database_dt_state != 'All':
        filtered_history_df = filtered_history_df[filtered_history_df['DATABASE_NAME'] == selected_database_dt_state].copy()
    if selected_schema_dt_state != 'All':
        filtered_history_df = filtered_history_df[filtered_history_df['SCHEMA_NAME'] == selected_schema_dt_state].copy()
    if selected_table_dt_state and 'All' not in selected_table_dt_state:
        filtered_history_df = filtered_history_df[filtered_history_df['TABLE_NAME'].isin(selected_table_dt_state)].copy()
    elif not selected_table_dt_state:
        st.warning("No table(s) selected. Display will be empty.", icon="‚ö†Ô∏è")
        filtered_history_df = pd.DataFrame()

    if selected_state and 'All' not in selected_state:
        filtered_history_df = filtered_history_df[filtered_history_df['STATE'].isin(selected_state)].copy()
    elif not selected_state:
        st.warning("No refresh state(s) selected. Display will be empty.", icon="‚ö†Ô∏è")
        filtered_history_df = pd.DataFrame()

    if start_date and end_date:
        filtered_history_df = filtered_history_df[
            (filtered_history_df['DATA_TIMESTAMP_DT'].dt.date >= start_date) &
            (filtered_history_df['DATA_TIMESTAMP_DT'].dt.date <= end_date)
        ].copy()

    if filtered_history_df.empty:
        st.info("No data available based on current filter selections. Please adjust your filters.", icon="‚ÑπÔ∏è")
        return

    # --- Refresh Trends & Distributions ---
    st.subheader("Refresh Trends & Status Over Time")
    chart_cols_state_row1 = st.columns([1, 1])

    with chart_cols_state_row1[0]:
        st.markdown("<p style='font-size:16px;'><b>Refresh Status Trend</b></p>", unsafe_allow_html=True)
        st.write("Count of refreshes by state over the selected time range.")
        if not filtered_history_df.empty:
            # Aggregate by date and state
            status_trend_df = filtered_history_df.groupby([
                pd.Grouper(key='DATA_TIMESTAMP_DT', freq='D'), 'STATE'
            ]).size().unstack(fill_value=0).reset_index()
            status_trend_df.rename(columns={'DATA_TIMESTAMP_DT': 'Date'}, inplace=True)

            # Sort states for consistent color mapping and legend
            state_order = ['SUCCEEDED', 'FAILED', 'UPSTREAM_FAILED', 'CANCELLED', 'EXECUTING', 'SCHEDULED']
            present_states = [s for s in state_order if s in status_trend_df.columns]
            
            # Melt for stacked bar chart
            status_trend_melted = status_trend_df.melt(
                id_vars=['Date'], 
                value_vars=present_states, 
                var_name='State', 
                value_name='Count'
            )
            
            fig_status_trend = px.bar(
                status_trend_melted,
                x='Date',
                y='Count',
                color='State',
                title='Daily Refresh Status Trend',
                color_discrete_map={
                    'SUCCEEDED': 'green', 'FAILED': 'red', 'UPSTREAM_FAILED': 'darkred',
                    'CANCELLED': 'orange', 'EXECUTING': 'blue', 'SCHEDULED': 'grey'
                }
            )
            fig_status_trend.update_layout(barmode='stack')
            st.plotly_chart(fig_status_trend, use_container_width=True)
        else:
            st.info("No data for Refresh Status Trend.", icon="‚ÑπÔ∏è")

    with chart_cols_state_row1[1]:
        st.markdown("<p style='font-size:16px;'><b>Refresh Action Distribution</b></p>", unsafe_allow_html=True)
        st.write("Distribution of refresh actions (e.g., INCREMENTAL, FULL, NO_DATA).")
        if 'REFRESH_ACTION' in filtered_history_df.columns and not filtered_history_df.empty:
            action_counts = filtered_history_df['REFRESH_ACTION'].value_counts().reset_index()
            action_counts.columns = ['Action', 'Count']
            fig_action_dist = px.pie(
                action_counts,
                values='Count',
                names='Action',
                title='Refresh Action Distribution',
                hole=0.3
            )
            fig_action_dist.update_traces(textposition='inside', textinfo='percent+label')
            st.plotly_chart(fig_action_dist, use_container_width=True)
        else:
            st.info("No REFRESH_ACTION data available.", icon="‚ÑπÔ∏è")

    st.divider()

    # --- Refresh Duration Analysis ---
    st.subheader("Refresh Duration & Row Change Analysis")
    chart_cols_state_row2 = st.columns([1, 1])

    with chart_cols_state_row2[0]:
        st.markdown("<p style='font-size:16px;'><b>Refresh Duration Distribution</b></p>", unsafe_allow_html=True)
        st.write("Distribution of refresh durations.")
        if 'REFRESH_DURATION_SEC' in filtered_history_df.columns and not filtered_history_df['REFRESH_DURATION_SEC'].empty:
            duration_data = filtered_history_df['REFRESH_DURATION_SEC'].dropna()
            
            # Max duration for slider/histogram range
            max_duration = duration_data.max() if not duration_data.empty else 60
            
            # Allow user to select max duration for histogram
            duration_max_limit_sec = st.slider(
                f"Max Duration for Histogram (seconds):",
                min_value=0.0,
                max_value=float(max_duration),
                value=min(float(max_duration), 3600.0), # Default to 1 hour or max if less
                step=10.0,
                format="%.0f s",
                key="duration_hist_limit"
            )

            # Filter data for histogram based on slider limit
            duration_data_for_hist = duration_data[duration_data <= duration_max_limit_sec]

            if not duration_data_for_hist.empty:
                fig_duration_hist = px.histogram(
                    duration_data_for_hist,
                    x="REFRESH_DURATION_SEC",
                    nbins=20, # Adjust bins as needed
                    title='Refresh Duration Distribution',
                    labels={'REFRESH_DURATION_SEC': 'Duration (seconds)'}
                )
                fig_duration_hist.update_layout(bargap=0.1)
                st.plotly_chart(fig_duration_hist, use_container_width=True)
            else:
                st.info("No refresh duration data within selected range.", icon="‚ÑπÔ∏è")
        else:
            st.info("No REFRESH_DURATION_SEC data available.", icon="‚ÑπÔ∏è")


    with chart_cols_state_row2[1]:
        st.markdown("<p style='font-size:16px;'><b>Row Change Overview</b></p>", unsafe_allow_html=True)
        st.write("Total inserted, deleted, and copied rows per refresh action.")
        # Need to handle STATISTICS column being an OBJECT.
        # Assuming get_dt_refresh_history flattens it into separate columns like NUMINSERTEDROWS
        row_change_cols = ['NUMINSERTEDROWS', 'NUMDELETEDROWS', 'NUMCOPIEDROWS']
        if all(col in filtered_history_df.columns for col in row_change_cols):
            # Sum up rows by refresh action for simplicity
            row_change_summary = filtered_history_df.groupby('REFRESH_ACTION')[row_change_cols].sum().reset_index()
            row_change_melted = row_change_summary.melt(
                id_vars='REFRESH_ACTION',
                value_vars=row_change_cols,
                var_name='Row_Metric',
                value_name='Count'
            )
            fig_row_change = px.bar(
                row_change_melted,
                x='REFRESH_ACTION',
                y='Count',
                color='Row_Metric',
                title='Row Changes by Refresh Action',
                barmode='group', # or 'stack'
                labels={'REFRESH_ACTION': 'Refresh Action', 'Count': 'Number of Rows'}
            )
            st.plotly_chart(fig_row_change, use_container_width=True)
        else:
            st.info("Row change statistics (NUMINSERTEDROWS, etc.) not available or not properly flattened.", icon="‚ÑπÔ∏è")
    st.divider()

    # --- Detailed Failed Refreshes Table ---
    st.subheader("Failed & Cancelled Refreshes Details")
    st.write("Detailed list of dynamic table refreshes that did not succeed.")

    failed_refreshes_df = filtered_history_df[
        filtered_history_df['STATE'].isin(['FAILED', 'CANCELLED', 'UPSTREAM_FAILED'])
    ].copy()

    if not failed_refreshes_df.empty:
        # Sort by REFRESH_END_TIME (descending) or DATA_TIMESTAMP_DT
        failed_refreshes_df = failed_refreshes_df.sort_values(
            'DATA_TIMESTAMP_DT', ascending=False
        )

        # Select columns to display in the table
        display_cols = [
            'QUALIFIED_NAME', 'STATE', 'STATE_CODE', 'STATE_MESSAGE', 'QUERY_ID',
            'DATA_TIMESTAMP_DT', 'REFRESH_START_TIME_DT', 'REFRESH_END_TIME_DT',
            'REFRESH_DURATION_SEC', 'REFRESH_ACTION', 'REFRESH_TRIGGER'
        ]
        
        # Apply formatting for duration
        if 'REFRESH_DURATION_SEC' in failed_refreshes_df.columns:
            failed_refreshes_df['REFRESH_DURATION_FMT'] = format_seconds_to_readable(
                failed_refreshes_df['REFRESH_DURATION_SEC'], time_format_option
            )
            display_cols[display_cols.index('REFRESH_DURATION_SEC')] = 'REFRESH_DURATION_FMT'

        # Rename columns for display
        display_labels = {
            'QUALIFIED_NAME': 'Dynamic Table',
            'STATE': 'State',
            'STATE_CODE': 'Code',
            'STATE_MESSAGE': 'Message',
            'QUERY_ID': 'Query ID',
            'DATA_TIMESTAMP_DT': 'Data Timestamp',
            'REFRESH_START_TIME_DT': 'Refresh Start',
            'REFRESH_END_TIME_DT': 'Refresh End',
            'REFRESH_DURATION_FMT': 'Duration',
            'REFRESH_ACTION': 'Action',
            'REFRESH_TRIGGER': 'Trigger'
        }

        # Filter to only existing columns and rename
        final_display_df = failed_refreshes_df[
            [col for col in display_cols if col in failed_refreshes_df.columns]
        ].rename(columns=display_labels)

        st.dataframe(final_display_df, use_container_width=True)
    else:
        st.info("No failed or cancelled refreshes found based on current filters. Great news!", icon="üéâ")
